   #+hugo_base_dir: d:/Hugo/myblog/
   #+hugo_section: post  
   #+hugo_auto_set_lastmod: t
   #+hugo_code_fence: nil  
   #+hugo_front_matter_key_replace: description>summary
   #+hugo_custom_front_matter: image img/111.jpg
   
* Blog
** DONE Hugo blogging with Ox-hugo 【用 ox-hugo 在 Emacs 中搭建网站流】 :@TECH:Hugo:Ox_hugo:
   CLOSED: [2019-07-16 Fri 01:03]   
   :PROPERTIES:
   :EXPORT_FILE_NAME: Hugo blogging with Ox-hugo
   :END:
   :LOGBOOK:
   - State "DONE"       from "DONE"       [2019-07-24 Wed 00:42]
   :END:

#+begin_description 
My personal experience of blogging with Emacs/Spacemacs and plug-in ox-hugo, along with some explanation of Hugo's working structure.
#+end_description

There have been many good articles talking about using ~ox-hugo~ to help with
efficient blog-writing in Emacs/Spacemacs. I read these articles carefully
several times and feel pretty confident using ox-hugo, so I would strongly
recommend you give them a look:

[[/img/Hugo blogging with Ox-hugo 8.png]]
This is true for many cases, but no, not for Hugo or ~ox-hugo~. Ox-hugo has an amazing official documentation! (Mr.Kaushal I know you occasionally search ~ox-hugo~ related articles in all different languages. If you happen to read this, thank you!)

• [[https://ox-hugo.scripter.co/][ox-hugo official documentation]] is very well written. The author carefully demonstrates not only all basics of using ~ox-hugo~, but also some killer choices to improvise. 

• [[https://gtpedrosa.github.io/blog/using-org-mode-and-ox-hugo-to-replace-markdown-in-hugo-workflow][USING ORG MODE AND OX-HUGO TO REPLACE MARKDOWN IN HUGO WORKFLOW]] and the three other articles mentioned are very helpful to me too.

• [[https://www.kengrimes.com/ox-hugo-tutorial/][Ken's ox-hugo tutorial]] is the source of some of my sections mentioned below, which you can see the snapshots are directly from Ken's blog. I re-edit it to help understand the logic of the section tree. 
 
The content of this article comes from the Hugo official documentation along
with the above articles. I am writing in Chinese because I noticed that there
haven't been many Chinese articles talking about Hugo and ~ox-hugo~. If you are
proficient English readers, the official documentation and links above should be more than
enough to get things done.

我放弃 Hexo，安装 Hugo 的最初目的还是想用它配合 Emacs-org-mode 来写博客记笔记。灵感来自[[https://zilongshanren.com/post/move-from-hexo-to-hugo/][子龙山人]]和[[https://www.xianmin.org/post/ox-hugo/][贤民]]两位老师的博客，具体的安装和使用心得二位已经介绍的非常详细，仔细读完会受益良多。本着不再重复造轮子的原则，这篇文章我想简单写写学习中遇到到有用的东西：Hugo 原生的结构设计；Hugo 与 ~ox-hugo~ 的对接原理；在 Emacs/Spacemacs 使用 ox-hugo 帮助我们在 org-mode 以极高的效率写博客并发表。

在阅读本文之前，强烈推荐阅读开头推荐的三部分内容。本篇博客主要就是整理了加工了一些来自 Hugo 官网，和以上三篇文章的内容，并配以更直观的图片帮助理解。对我来说 ox-hugo+org-mode 最牛的地方的在于高度集成 org-mode 有一个优秀的原生功能是通 tags 等功能，用一个大文件+一二三四五级小标题就能管理一个文本文件树。具体到本文就是，通过一个文件管理整个网站的内容撰写。这是作者力荐的写作方式，也是他编写这个插件的主要初衷。比起各种单个文件组成的零散网站管理模式，这个结构更清晰，管理更容易，搜索 toggle 都十分方便。作者用 ~ox-hugo~ 的官网直接展示了样版：
[[https://ox-hugo.scripter.co/doc/why-ox-hugo/][Why ox-hugo? — ox-hugo - Org to Hugo exporter - https://ox-hugo.scripter.co/]]

这样的结构配合上一些 Emacs 自带的 killer 功能例如 ~writeroom-mode~,
~org-tree-to-indent-buffer~ , ~predictive~ 英文补全, ~org-capture~ 一键捕获，能瞬
间让写作如虎添翼。

*** 0. Org markup syntax and killer reference card
-----
我对 org-mode 语法细节记忆仍然感觉十分困难。官网给了零星几个常见的语法
参考，但是 org-mode 能定制格式花样的远不止于此。我在此给出一个终极解决方式：参考网站原文的
org file。网站 org 源码从 org markup 形式到 hugo section 的 front information 都有涵盖，在网站
看到想要的格式去原文直接搜索照搬即可：
Most efficient way to use org syntax is digging source samples from the official website:
[[https://ox-hugo.scripter.co/doc/hugo-section/][Full website]]
[[https://raw.githubusercontent.com/kaushalmodi/ox-hugo/master/doc/ox-hugo-manual.org][Full website source file]]

*** 1. Front matter 页首信息
-----
Hugo 本身其实支持直接把.org 文件渲染成 HTML 发布，但是许多人提到其实支持得不是很好。Hugo 支持最好的 markdown 语法类型是 blackfriday markdown。对很多 Emacs user 来说 org-mode 就像把有力的大锤，碰上跟写作沾边的任务不能抡一下是很遗憾的。所以可以使用这款非常棒的后端插件 ~ox-hugo~ 来支持 org-mode 写博文。它的解决方式是：把 org 文件转成 blackfriday markdown, 然后再生成 HTML 文件。首先我们详细看 ~ox-hugo~ 官网对其功能的解说：

#+begin_quote
According to the information documentation, ~ox-hugo~ is an Org exporter backend that exports Org to Hugo-compatible Markdown (Blackfriday) and also generates the front matter (in TOML or YAML format).
#+end_quote 

	
简言之，我们主要使用 ~ox-hugo~ 做两件事（1）把 org 格式内容转换成 markdown 格式内容；（2）解析 org file 中的用 org 语法写 front-matter，生成 Hugo 要求语法的 front-matter，使得 Hugo 通过正确的信息生成的 HTML 。那么 front-matter 具体指什么呢？



Front matter give the information about the content, but NOT the information of content. It works as metadata to tell Hugo the general properties of the article. Hugo supports three types of front matter syntax: yaml, toml, json. Whenever you generate a new post/article/blog with
#+begin_src 
$ hugo new site posts 
#+end_src
Hugo will automatically add front matter information at the top of the article like this:
#+begin_src 
	---
	title: Good day
	date: 2017-09-01T1705-43                    (YAML)
	draft: true
	---
	
	+++
	title= Good day
	date= 2017-09-01T1705-43                   (TOML)
	draft= true
	+++
	
	{ 
	"title":  "Good day" ,
	"date": "2017-09-01T1705-43",           (json)
	"draft": "true"
    }
#+end_src
	
所以想用 org 进行 blog 写作，也需要定义自己的 front matter. 但是 org file 里 front matter 语法如下
#+begin_src lisp
:PROPERTIES:
:EXPORT_FILE_NAME: ox-hugo-tutorial
:EXPORT_DESCRIPTION: Exporting to Hugo's Blackfriday Markdown from Orgmode
:EXPORT_HUGO_IMAGES: /img/org.pn
:END:
#+end_src

以 ~:properties:~ 这块为代表的代码就是 org 以自己的方式定义 meta
information。~ox-hugo~ 会解析改写这个这些代码以生成 hugo 可以识别的 YAML 等 front matter.
Ox-hugo 一般要求至少要有 ~:EXPORT_FILE_NAME:~ 。我们需要通过这个命令告诉
ox-hugo"有新的标题和内容需要去导出"。

*** 2. Don't get confused 易混淆的概念
接下来这个问题可能对多大多数前端 coder 和 Emacs 熟练手都不是问题，但是这两个段头部代码被我着实混淆了一阵：
	
通用 Front matter 主管面向一个 article 内部的性质设置，例如写作作者，写作日期，写作 tag。Heading information 例如 ~#+hugo_base_dir~ 的概念局限于 ~ox-hugo~ 里，是遵从
org-mode 特色的命名方式设计的变量，类似的语法在其他 org 文章的管理信息中也可以
看到。而 front-matter 这些变量
在 markdown，网页 config file 等其它文件里都有。只是 ~:PROPERTIES:~ 这种表达形式
是 ox-hugo 特色写法。换做 org 支持的另一种 projectile 导出 HTML 的 front matter 可能是这样:base-directory "~/Dropbox/org/blog/".

*** 3. Content type
-----
	Content type 就是一系列不同的表达式样（layout），根据我们指定的不同的 section type 有不同表达式样法则，这里暂且把 section 翻译成一个网站下的不同栏目，例如 blog，photo，quote，post，about，tages 或者其它你想自定义的栏目。Hugo 通过 front-matter 支持这些不尽相同的 content type。
	
	Hugo 认为每个栏目最好只做同一件事情，例如照片专栏只发发照片，post 专栏集中发文章。所以除非我们自定义，hugo 指定每个栏目的子单元都会自动继承一些此专栏 pre-defined 的特性，这样能最大限度的重复使用一个定义好的栏目，同时尽量减小‘config 每个栏目’工作。
	
	设定 content type: 只需在源文件的头部引用 hugo 提供的 heading
	information/metadata information（即 front matter）即可，能迅速方便的修改一
	两个页面的 layout。如果不能满足需求，可用 hugo 提供的自定义设置 archetypes，
	按照 hugo 指定的结构组合方式，编写正确的_index.md 文件拼接好一个网站的
	layout 即可。 
	
	如果你没有指定表达式样，比如暂时不太在乎如何展示 photo 这个栏目，Hugo 有这么
	一个 default 设定：在 front matter 大部分信息缺乏的时候，通过每个文章存储
path 或者所在 section 猜出给这篇文章赋予什么 layout。这会让我们在迅速上手写
	作 blog 的时候非常省心。

*** 4. Page bundles
-----
	Hugo 0.32 以上的版本，使用 page bundles 的模式来管理网页源和图，从父子结构分类的角度看，有两种：leaf 类页面和 branch 类页面。branch 类页面允许在其内部嵌套更深层次的页面，而 leaf 规定其不能再有子页面。
	
	任何一个叫 index 的页面文件都是 leaf 型，叫_index 的页面文件都是 branch 型。所以可见 org 文件里 index 的文件都会被输出成单页，没有子文件夹。最常见的 index 页面是下文会提到的分类里面的 categories 和 tags index pages，它们都是单页，除此之外多数时候我们会使用 branch 型。如图:
[[/img/Hugo blogging with Ox-hugo 1.png
]]
	Content 文件夹在这里是 home page, 他的主要功能是 hosting“决定网站 layout 设定”的信息（在这里就是定义了 branch 型页面类型的_index.md），所以 hugo 规定 home page 至多只能包含图片，而不能包含其它的 content pages，只承担 layout 设定而不为 article source 提供场所。注意 content 里面的内容结构安排，应当和你想要渲染的网站结构一致。

*** 5. Section and nested section
-----	
Section 是一组页面的集合称呼，一般被放在 content 文件夹下面，就是上文提到的‘内容结构组织’的组成单元。从 default 设定来讲，content 下面的每个一级文件夹自成一个 root section。同时上面也提到 section 可以嵌套，即在一级文件夹下方再建二级 section 文件，构成一个更深层的 section。
    
	
	那么问题来了，hugo 是如何知道 nested section 呢? 答案是：通过文件夹里要有_index.md 文件指定结构的设定。依此原理可以构建三级四级更深的 section 目录。 为了确保每一级网页都能被导览正确的链接到，每个最底层的文件夹里都要至少包含一个有内容文件，例如_index.md.
#+begin_src 
content
└── blog        <-- Section, because first-level dir under content/
    ├── funny-cats
    │   ├── mypost.md
    │   └── kittens         <-- Section, because contains _index.md
    │       └── _index.md
    └── tech                <-- Section, because contains _index.md
        └── _index.md
#+end_src

*** 6. Head information
-----
~ox-hugo~ 对 org 文件存放位置并没有特定要求，但是其头部的 ~#+hugo_base_dir:~ 必
须要被清晰的定义，因为这个地址告诉 ~ox-hugo~ 你的 root directory 在哪里，
~ox-hugo~ 就会在这个地址下的 content 里面生成转化的 md 文件。很多用户自定义
~#+hugo_base_dir:~ ..即是本 org 文件所在的 parent path.也有人定义
~#+hugo_base_dir:~ .代表 path 与现在的 org 文件同文件夹，如果 root directory 是
跟现在 org 文件同文件夹，c-c c-e H A 导出 markdown 文件的结果就是这样：
[[/img/Hugo blogging with Ox-hugo 2.png]]

	仔细体会以下示例：以 root 目录 c:\hugo\myblog\为例：
	(1) orgfile 在 myblog 下方 且#+hugo_base_dir: .
	(2) orgfile 在 myblog\content-org 下方 且#+hugo_base_dir: ..
	在 c-c c-c H A 后都会产生如下形式，只不过(2)中 hugotest.org 在 content-org 里面
[[/img/Hugo blogging with Ox-hugo 3.png]]

*** 7. Heading management
-----
The official documentation as well as the attached youtube tutorials have
provided great explaintation of how hugo translate metadata of _index.md files
to the headings of HTML with Hugo heading management system.
	
建立一个有一篇文章的 post
[[/img/Hugo blogging with Ox-hugo 4.png]]

继续新增一个有两篇文章的 fishsticks
[[/img/Hugo blogging with Ox-hugo 5.png]]

*** 8. Tree and subtree writing
-----	
In normal Hugo, individual pages written in markdown (or now in org-mode)
	are placed inside the content directory inside the project root. With ~ox-hugo~, a single org-mode file can be used to generate all pages, posts, and any other content. This has some advantages in allowing usage of org-mode functionality, as well as re-use of content or property settings across pages.

[[/img/Hugo blogging with Ox-hugo 6.png]]

*** 9. Taxonomies 分类型页面
-----
这段是 index 管理 page boundle 的良好功能的又一个展现:通过 taxonomy index pages 就能建立一系列分类页面,例如 tags and category,为分类页面单独建立管理 page 使拥有这些属性的文章被自右交叉引用,用户可以通过点击任何一个 tag 或者 categories 就能达到文章页面。在 org 写作里通过在 headings 添加实现，org 到 md 转化由 ~ox-hugo~ 完成，语法差别很细微。如下图，还是上文的源码，只是为文章添加了两种 categories，两种 tag:
[[/img/Hugo blogging with Ox-hugo 7.png]]

在源码的三篇文章里分类 update 和 reviews 被提到两次，标签 fear 和 herpes 也被提到两次。从生成的 HTML 来看，
index.md 刚好与之对应：分类的 index page 提供了所有需要的分类（i.e. tags, categories）每个分类下还有 list page 显示所有与之相关的页面内容。导航就是这样实现建立的，使得我们能“实现不同分类间的交叉引用，点击任何一个入口进入文章”。

** DONE Hugo Blogging with Wercker Auto Build & Deployment 【用 Wercker 自动部署网站】 :@TECH:Hugo:Git:Wercker:Org_mode:Emacs:
   CLOSED: [2019-07-26 Fri 01:02]
   :PROPERTIES:
   :EXPORT_FILE_NAME: Hugo Blogging with Wercker Auto Build & Deployment
   :END:

#+begin_description
Using Wercker to for automated website code build and deployment
#+end_description

The automated static website generators (e.g. Octopress, Hexo and Hugo) have made *website building and maintaining* way more relaxed than before. The workflow has been simplified to: write and save markdown -- preview on the localhost 1313 -- generate the ~/public (HTML) file -- push to a remote server (GitHub) -- backup source code. 

If one considers all technicalities, there are still many questions worth discussing to make this process more efficient, such as (1) which is the best way to host HTML files and source code files (2) which is the better way to automate the procedure.

I used to use Hexo where three things need to be tracked separately:  source code and ~/public file (both updated for every article), forked/cloned theme (updated according to theme author) and Hexo generator. I have to use git submodules to track everything. Soon, the hustle and page generation speed make me convert to Hugo. Hugo requires only a binary file to generate a website, with which the update cannot be more straightforward: you download a new .exe file and replace the old one. The updated theme can be manually merged as long as the site config.toml file is well preserved. 

Let's go back to the first issue. The Hugo official manual has given two way to publish ~/public file: (1) using Master branch of user.github.io to host /doc (instead of public) folder, which is the easiest one to me; (2) using gh-pages and the advantage of this method is that allows you to have another branch hosting source code in the same repo. I fail to generate /doc file somehow, but it gives me a chance to try Wercker, which surprisingly allows me to achieve the first method with the same advantages of the second method. Long story short, now I am using the Master branch of user.github.io to host ~/public file and dev branch to host source file.

My answer to the second issue is using Wercker. It will automatically go to your source code repo and build the ~/public folder and deploy the website. So the process mentioned at the beginning of this article becomes even easier: write and save an article in markdown -- push the whole source code to the remote repo. This means you do NOT need to generate and deploy in the local terminal any more. Wercker does the work every time it detects a new push on the designated repo on the remote server. The script  wercker.yml (generated and pushed by you) will tell Wercker precisely how and where to build and deploy. There're also other popular continuous integration tools such as Travis CI, Jenkins which has advantages at different aspects such as free usage, commercial stability, running speed and etc. I choose to use wercker based on my needs.

The Hugo instruction [[https://gohugo.io/hosting-and-deployment/deployment-with-wercker/]] is very detailed and well written, and you should be quite clear before the 'Configure Access' section. The Wercker has changed quite a bit in the generating wercker.yml part. You do NOT HAVE to search and choose boxes or steps to build and deploy. The default script contains the box information, and it can be modified unless you don't like it. The build and deploy part are generated separately in the workflow section (press CTRL and + to see the bigger picture) [[D:/Hugo/myblog/static/img/Hugo blogging with werecker 1.png]] 

Here is my wercker.yml:

#+begin_src yml
# This references a standard debian container from the
# Docker Hub https://registry.hub.docker.com/_/debian/
# Read more about containers on our dev center
# https://devcenter.wercker.com/overview-and-core-concepts/containers/
box: debian
# You can also use services such as databases. Read more on our dev center:
# https://devcenter.wercker.com/administration/services/
# services:
    # - postgres
    # https://devcenter.wercker.com/administration/services/examples/postgresql/

    # - mongo
    # https://devcenter.wercker.com/administration/services/examples/mongodb/

# This is the build pipeline. Pipelines are the core of wercker
# Read more about pipelines on our dev center
# https://devcenter.wercker.com/development/pipelines/
build:
    steps:
    # Steps make up the actions in your pipeline
    # Read more about steps on our dev center:
    # https://devcenter.wercker.com/development/steps/
        - arjen/hugo-build@2.8.0:
            # your hugo theme name
            theme: hugo-theme-cleanwhite
            flags: --buildDrafts=false
deploy:
    steps:
        - install-packages:
            packages: git ssh-client

        - sf-zhou/gh-pages@0.2.6:
            token: $GIT_TOKEN
            domain: sheishe.xyz
            repo: QiKatherine/QiKatherine.github.io
            branch: master
            basedir: public
#+end_src

Notice the name 'build' and 'deploy' in the workflow above need to be the same with the name in steps in the wercker.yml file.

You can also add a local deploy.sh to make source code push easier too:

#+begin_src bash
  #!/bin/bash
  cd ~/Hugo/myblog/

  # Add changes to git.
  git add .

  # Commit changes.
  msg="rebuilding site `date`"
  if [ $# -eq 1 ]
    then msg="$1"
  fi
  git commit -m "$msg"

  # Push source and build repos.
  git push origin -u dev

#+end_src

Happy hacking! :)

** DONE Best workaround to use Emacs in MS Windows 【在 MS windows 中使用 Emacs 的最佳解决方案】 :@TECH:Emasc:Msys2:Windows10: 
   CLOSED: [2019-08-16 Fri 01:03]
   :PROPERTIES:
   :EXPORT_FILE_NAME: Best workaround to use Emacs in MS Windows
   :DESCRIPTION: Compiling Emacs with msys2 environment.
   :END:
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2019-08-16 Fri 01:03]
   :END:

#+begin_description
Experience Emacs with best workaround environment in windows.
#+end_description

*** Background 
-----
Due to the working environment limitation, I occasionally have to use MS windows system (and therefore Emacs for Windows). But some similar users and I have constantly found cases where Emacs is significantly relying on *unix system. So far, my experience is that compiling Emacs in msys2 has been a best (maybe) workaround in this situation. If you this is relatable to you, you might want to give it a try:
https://chriszheng.science/2015/01/23/Guideline-for-building-GNU-Emacs-with-MSYS2-MinGW-w64/
There has been ample discussion online, so I will be writing in Chinese. If you are interested in the trouble shootings below, try google translate. It will be fun :).


我因为工作的原因有时候不得不使用 Windows。Emacs for Windows，在这种情况下，已经是一个比较合适的选择了，我用了半年多对它各方面都还相对满意。但是总不时会发现，Emacs 里面还有很多严重依赖*Unix system 的操作。为了找到一劳永逸的办法（做梦），我尝试过 cygwin, mingw64 还做了一些功课，目前发现最好方式是，将整合到 msys2 里面使用，或者使用 msys2 编译的 Emacs。

*** MSYS2
-----
MSYS2 是 MS-Windows 下编译自由/开源软件的一个环境，衍生自 Cygwin，也就是说它和 Cygwin 一样，编译出的程序不能脱离 Cygwin 环境运行(其实就是离不开那几个 DLL 文件)。但 MSYS2 有一个很牛的地方是它自带了 MinGW-w64，MinGW-w64 可以认为是 MinGW 的升级版本，编译出的程序是原生的 Windows 程序，最大的特点和名字一样，支持编译出 64 位的程序。目前 MSYS2 和 MinGW-w64 开发都很活跃，两者结合，既发挥了 MSYS2 对*NIX 世界的兼容性，又能用 MinGW-w64 编译原生代码，很爽，自带的包很丰富，包管理采用 Arch Linux 用的 Pacman，非常的方便。

据说 msys2 目前是提供最多类 Unix 开发工具的环境，而且为想尝试*unix 的 windows users 整体上提供了十分优秀的模拟环境。

Msys2 的下载安装都很简单，参照管网指南操作即可。中文用户配置可以参考以下链接：
https://zhuanlan.zhihu.com/p/33751738
https://zhuanlan.zhihu.com/p/33789023

*** Compiling Emacs
-----
/在 msys2 里面安装最简单的是使用 pacman -S Emacs，安装完的版本在 c:/msys2/usr/bin 里，dotfile 在 c:/msys2/home/user/.emacs.d 下方，我试图运行内置 function，正常，但是使用 dotfile 加载同样的 function 总显示加载错误。/ 

而且 chris 老师提到 Windows 下使用 emacs 最好的方式还是用自己编译的 Emacs，所以我也选择这么做。自编译 Emacs 要安装一系列 libraries，然后从原代码 git.sv.gnu.org/emacs.git 从这里 clone 所有的东西下来，按下列文章一步一步编译
https://emacs-china.org/t/topic/3276/13
https://chriszheng.science/2015/03/19/Chinese-version-of-Emacs-building-guideline/
http://git.savannah.gnu.org/cgit/emacs.git/tree/nt/INSTALL.W64

这个安装包都是为了在 msys2 中编译 Emacs 而写，所以安装途中不需要由什么特别改动的地方，注意一步一步执行代码就好。还有一点不得不提，Gti 自动改换行符的功能(autocrlf)很讨厌，会造成各种意想不到的神仙 bug（e.g. 很多人猜测这个也是造成 spacemacs 版本的 font-lock+ error 的原因）我们用下面的命令关掉它：
$ git config core.autocrlf false
=Update: 新版的git已经默认这项是关闭了。如果有需要，可以安装完后再把值改回true，一直默认关闭会导致有些git操作持续return warning，泪目。=

安装时需要一些依赖库，如果你的系统里面 MSYS2 已经被添加到 PATH 环境变量里(例如 PATH 里包含了 C:\msys2\mingw64\bin)，就不用从 mingwin64/bin 里面复制必用的 libraries 去 c:/emacs1/bin 了，所以直接在 PATH 里添加环境会比较方便。

*** Advantages
-----
跟以前使用的 Emacs for MS Win64 一样，emacs 配置文件还是默认在 C:/Users/AppData/Roaming/.emacs.d 中。大多数 package 放在本地 c:/msys2/home/user/.emacs.d/elpa/yourdir/以后使用 ~(add-to-list 'exec-path "yourdir")~ 即可正常调用。

但是我感觉从运行速度来讲，msys2 compiled Emacs 比 Emacs for Win64 =快很多= 。所以在 win 中使用 Emacs，虽然也有 WSL 或者 VM based 的解决
方案，但是 msys2（在许多人看来）仍然是一个在 win 环境中使用类 unix 系统的优秀途径，希望未来能研究编译过的 emacs 在 msys2 提供的类 unix 系统里是否和其他 libraries 有更好的互动。

** DONE Org-reveal: solution for math and code highlighting in presentation slide 【在 ppt 中展示代码高亮，数学公式的优秀解决方案】 :@TECH:Emacs:Org_mode:
   CLOSED: [2019-08-23 Fri 22:50]
   :PROPERTIES:
   :EXPORT_FILE_NAME: org-reveal-solution-for-math-and-code-highlighting-in-presentation-slide
   :END:
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2019-08-23 Fri 22:50]
   - State "TODO"       from "DONE"       [2019-08-22 Thu 00:54]
   - State "DONE"       from "TODO"       [2019-08-22 Thu 00:44]
   :END:
 
#+begin_description
Learning notes and trouble shooting for using org-reveal.
#+end_description

I have used flash card for remembering new things for years. Before using software like org-drill or Anki, I was pretty much putting everything in slides, printing on papers and cutting it into a portable sized card and carried in my pocket. So I have been exploring an ultimate solution of perfect formatting for everything. This picture shows what I feel about slides making tools.
[[../static/img/org-reveal.jpg]]

I always thought math functions display tricky, but the Latex with Beamer has provided an adequately good template for most people. As a comparison, the code highlighting is trickier, especially for not-so-prevalent programming languages like Lisp. In order to adequately demonstrate code highlighting, sometimes people have to paste code in Notepad++ with designated formatting, then paste into MS word, then to MS PowerPoint. Or take an alternative hustle to explore various online highlighting transformation tool. If you are looking for a long term hustles solution, then I think "Emacs/Spacemacs + Org-mode + org-reveal" makes an excellent tool for you.
• [[https://github.com/yjwen/org-reveal/][yjwen/org-reveal: Exports Org-mode contents to Reveal.js HTML presentation. - https://github.com/]]
• [[https://opensource.com/article/18/2/how-create-slides-emacs-org-mode-and-revealjs][How to create slides with Emacs Org mode and Reveal.js | Opensource.com]]
• [[https://revealjs.com/?transition=fade#/][reveal.js – The HTML Presentation Framework - https://revealjs.com/]]

The above links give many details of the code/manual/demo of org-reveal.Specifically, the second and third links provide excellent instruction about how to toggle and customize your presentation. I highly recommend you to give them a look.

In this article, I am only adding a few trouble shootings for the issue that I met.

The installation did three things (1)installing ox-reveal (2)installing reveal.js (3)installing htmlize, but the spacemacs comes with htmlize installed.

I add ox-reveal in the package list of spacemacs dotfile, reloading the dotfile but it did not installed. The author also mentioned that ox-reveal in MELPA maybe out of date. So alternatively, I downloaded the .el file and manually required it.

There are also two ways of calling reveal.js as described by the readme. I am using the second where the source url was put in the config file. Notice there seems to be an old url(http://cdn.jsdelivr.net/reveal.js/3.0.0/) which does NOT work any more. If your exported HTML file is just an empty page with theme background, check if you are referring to the right url. The current source and config code is shown below:


#+begin_src emacs-lisp
;; Emacs
(require 'ox-reveal)
(setq Org-Reveal-root "file:///path-to-reveal.js")
(setq Org-Reveal-title-slide nil)


;; Spacemacs/Using use-package
(defun yourname/post-init-ox-reveal ()
  (use-package ox-reveal
    :ensure t
  (setq org-enable-github-support t)
  (setq org-enable-reveal-js-support t)
  (setq org-reveal-root "https://cdn.jsdelivr.net/npm/reveal.js")))
#+end_src

** DONE Essentials in vanilla Emacs 【Vanilla Emacs 精华简介】  :@TECH:Emacs:
   CLOSED: [2019-08-25 Sun 23:51]
   :PROPERTIES:
   :EXPORT_FILE_NAME: mastering-emacs-in-21-days-learning-notes-day
   :END:
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2019-08-25 Sun 23:51]
   :END:

 #+begin_description
Learning notes about Emacs.
#+end_description

This article is part of my learning notes of Mastering Emacs in 21 Day, which is
a series of Chinese based tutorials post by [[https://github.com/zilongshanren][zilongshanren (子龙山人) -
https://github.com/]] The official learning note is at here: [[http://book.emacs-china.org/][Master Emacs in 21
Days - http://book.emacs-china.org/]] My notes extend the official notes with my
personal learning experience. Since there has been ample discussion of using and
learning Emacs in English community, my learning note is written in Chinese to
benefit more additional readers.

这篇文章是我学习子龙山人老师的 spacemacs rock 系列笔记之一。在原视频配套的基础上
我还做了一些扩展和补充，有的知识点还加了视频对应【集数-分钟】的时间点，以便迅速
观看视频.

*** 1. 基本知识 
-----
• Emacs 相当于一个 elisp based 的操作系统。这个操作系统的原理是，每次 Emacs 启动
过程就相当于一系列功能通过 loading files(代码块)的实现。在每次使用前，成百上千的
functions 被加载到 workspace 中(其中一些带着 default 参数) ，等待被调用，或者被
custermize。因此所有的设置，架构都可以通过调 function portal 修改成想要的 value；
或者在原有的 value/function 的基础上，继续开发一系列指令来增进，比如我们自己编写
的各种自定义函数。连整个 emacs 的启动都可以概括为一句话：加载一系列脚本。只不过
这些脚本有的是内置的（built in），有的来自安装的插件包，有的是我们自己写的。配置
emacs 归根结底是在配置各种各样的脚本。

• 首次加载一个配置复杂/成熟的 Emacs（例如 spacemacs 或 Purcell 的 Emacs），会耗
费比较长的时间，因为需要依次安装所有 cofig.el 中提到过的 packages。在经过首次配
置之后的时间里，每次启动 Emacs 的 loading file 主要以加载和更新为主，而极少数
package 安装只有才加载检查发现没有 package 时候才会发生。

• loading 的文件主要是.elc 文件，是经过编译的.el 文件的二进制形式，加载更快。但平日的修改是在更容易阅读的.el 文件上进行的，所以如果你手动修改完.el 文件，一定要记得编译以便 Emacs 自动执行，For example with Emacs-Lisp you do:

#+begin_src emacs-lisp 
 (byte-compile-file "foo.el")
#+end_src
否则 Emacs 要么加载没有被同步修改的二进制.elc 文件，要么会因为没找到.elc，去加载更缓慢的.el 文件。
	
• 光标放在最后一个反括号的末尾，按 C-x C-e，是执行一行命令 on the fly，作用等同于 M-x 命令 回车。

*** 2. 新建 init.el
-----
• 初始 hacking：
Emacs 像一个状态机，即使还没 config init.el, 裸机 Emacs 也加载了许多 build-in
functions 以确保能被基本使用。所有的状态在 default value 下运行。在这种情况下，
可以通过 M-x 调用已有的命令来做到修改设置，但是所有临时设置的东西关掉后都会被删
除，还原成默认值，被称为 =临时改动= 。还有一种就是直接去 el/.elc 的脚本里修改代
码 hard coding modify，有很多坏处。比如，每次更新插件，都要自己回去重新修改，被
称为 =永久改动= 。
	
• 初始化设置：
所以更好的选择是不动原脚本，通过预加载修改达到目的，也就是手动写一份 init.el 的意义。为了使得 emacs 每次打开都有最佳设置，我们在 C:\Users\AppData\Roaming\.emacs.d\文件下新建了 init.el 的 elisp 文件，来写想要的配置。因为 Emacs 默认设置打开时，会自动寻找 home 目录的.emacs.d\文件下下面 init.el 文件来执行：（1）如果找得到，每次开启 Emacs 都先重新执行一遍我们的 config，以达到预加载我想要的全部舒适配置；（2）如果其不存在 init.el，Emacs 还是原始裸机也能用；（3）如果 init.el 代码有错没加载成，也是裸机（后面使用 usepackage 来管理初始加载，可以避免这种“因为一点小错误”使得整个初始加载都失败”的问题）。
	=注意：** 如果希望把配置放在 ~/.emacs.d/init.el 文件中，那么需要手工删除 ~/.emacs 文件。=
	
• 使用 init.el 管理 personalized config 额外的好处是，init.el 文件还可以在
GitHub 备份，在初始化文件里加上一个系统类型判断函数，让我们在任何地方的的不同主流
系统都可以自由使用。甚至，不用修改别人电脑里有的 Emacs 配置，用 U 盘就能在一个 Emacs 里使用不同的 config。
	
	
• Emacs 的命令执行是按顺序来的，这个顺序既只文件也只内部命令。各种 function 一个
一个的被调用 （也就是 load/require），一行完成后再进行下一行。例如，只保存第 1 个命令，下次打开 Emacs 显示字体为 16pt；保存 1.2 命令，在 1 之上 load open-init-file 命令去 workspace；保存 1.2.3 命令，在 12 之上还能使得我们通过按 f2 真正调用这个 open-init-file:

#+begin_src emacs-lisp
;; 更改显示字体大小 16pt                                 
(set-face-attribute 'default nil :height 160)                   ---- 1

;; 快速打开配置文件
(defun open-init-file()
  (interactive)
  (find-file "~/.emacs.d/init.el"))                             ---- 2

;; 这一行代码，将函数 open-init-file 绑定到 <f2> 键上
(global-set-key (kbd "<f2>") 'open-init-file)                   ---- 3
#+end_src
这个知识点目前看起来很简单，但是以后涉及到要去其它.el 文件层层加载，记得这个顺序性 load 的特质会帮助理解 Emacs 的加载机制。
	
• 在 Emacs 里命令按行顺序执行 A--C，如果遇到“call A 的前提是先要加载 B function”（但是 B 没有加载在 workspace 里的情况时），Emacs 会先走开，去 B.el 相关的文件 load B function，执行完再回来继续加载剩余的东西，然后再执行 C。因此相互依赖的 feature 有可能因为调用顺序没安排好而导致 initiliaze 出错，这样能解决。为了解决依赖顺序造成的潜在问题，Purcell 写了一个 after-load 函数，目的是把一些相互依赖的 feature 的加载顺序理顺，例如 feature A 依赖于 feature B，则可以写成(after-load 'B 'A)，这样如果错误地在 B 之前 require 了 A 也不会影响正常启动：

#+begin_src emacs-lisp
(defmacro after-load (feature &rest body)
  "After FEATURE is loaded, evaluate BODY."
  (declare (indent defun))
  `(eval-after-load ,feature
     '(progn ,@body)))
#+end_src

*** 3. Major mode and minor mode
-----

• 在开始配置之前让我们先来区别 Emacs 中 major mode 与 minor mode 的区别。Major mode 通常是定义对于一种文件类型编辑的核心规则，例如语法高亮、缩进、快捷键绑定等。 而 minor mode 是除去 major mode 所提供的核心功能以外的额外编辑功能（辅助功能）。 例如在下面的配置文件中 /tool-bar-mode/ 与 /linum-mode/ 等均为 minor mode。

【查看 minor mode】简单来说就是，一种文件类型同时只能存在一种 major mode 但是它可以同时激活一种或多种 minor mode。鼠标放在 powerline 可以显示一些 minor mode 信息，如果你希望知道当前的模式全部信息，可以使用 =C-h m= 来显示当前所有开启 的全部 minor mode 的信息。（你如果发现已经设置过的 mode 没开，可能因为没有设置成 global 的）。

• major mode 里面还有一个重要的概念是 hook。一个 major mode（ /e.g.
Emac-lisp-mode/ ）相当于一个 list，就是一些它自带的 function。但这里还可以有一串
儿 minor mode 挂在上面。这个 major mode 开启默认所有 list 上的特性都会被自动加载。
如果我们需要的设置没有，需要手动添加，有可能是通过 hook，一般对于每个特定的 pack
如果使用 hook，GitHub 上有具体设置指南。例如 ~(add-hook 'emacs-lisp-mode-hook
'show-paren-mode)~ . 
[[/img/emacs 21 1-1.jpg]]
	
• Hook 就是一串特定的 functions: A hook is a Lisp variable which holds a list of functions, to be called on some well-defined occasion. 大部分 hook 都尽量是 normal 且一致的，方便全局调用，我们也会自己通过 add-hook 加 function 到 hook 上来满足特殊的需求。自行设计 hook list 要注意顺序问题，因为上文提到一串 function 是按顺序依次执行的，如果后面的会影响前面的，那么顺序自定义就很重要。相关阅读: [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Hooks.hrequest json-mode all-the-icons-dired edit-indirecttml][Hooks - GNU Emacs Manual - https://www.gnu.org/]]

• Emacs 操作系统很像一个大的状态机，储存着很多可修改的状态。Mode 调用和设置也是通过 function 修改 value 实现。Emacs 虽然因为没有变量空间而导致所有变量全局可见,但是因为 mode 的 default 设置，使得有些 value 只是 buffer local 的(aka mode 每个 buffer 都独立保留了一份 default 值)，如果需要在全局应用某些 mode，要注意上 hook 或者修改 global setting，注意查看每个安装文档的说明。

• 如上文所说，让 mode 生效有三种方式（1）临时调用 M-x company-mode，可以反复修改 value，但有可能只修改了临时 buffer local value（2）直接修改 mode.el 脚本；都不如这种好：(3) 写好 mode 设置放在 init.el 里面让它在 Emacs 开启时设置好。

以 company-mode 为例讲解以上知识：mode 的种类（还有其他 state）开启还
是关闭，本身是 value，每个 buffer 都有储存一份，所以 setq 只会修改本 buffer 的值，
setq-default 才会修改全体 buffer 的值。只有当一个 value 生来就是全局变动的时候，
setq 和 setq-default 才是一回事。set-key 也是类似，如下注意左右列的区别，尤其当
想要的修改下次没生效，查看变量是否是 buffer local 很重要。例如以下区别：

| Local setting           | Global setting                  |
| (company-mode t)        | (global-company-mode t)          |
| (setq cursor-type 'bar) | (setq-default  cursor-type 'bar) |
| (set-key ..)            | (global-set-key …)               |

*** 4. 在 init.el 中安装 packages
-----
	• 裸机 Emacs 系统除了部分内置的功能，什么 customized 设置都没有，因此我们手动安装想要 packages。第一次安装是从 option-manage packages 用 GUI 安装，等同于调用 M-x package-list-packages，但安装不仅是加载，系统同时自动同时在 init.el 生成 M-x package-list-packages list，以便以后在任何电脑上都可以自动复现。所以我们可以从 init.el 从命令的角度看看这是如何实现的。
	
	• 以后我们也会通过在 init.el 里编写 packages list 来实现群体安装。
	
	• 默认 packages 都装在.emacs.d/elpa 目录下面，即所有有关这个 package 的文件都下载到一个文件夹下面，以供 emacs load【注意这个跟.emacs.d/lisp 文件不要混淆】。

**** 4.1 Auto-load 
    • 装好后重新打开 Emacs，我们看到 init.el 文件第一行要求是
	~(package-initialize)~ 意思是自动去 elpa 目录里找安装好的 package，挨个扫描，找到 package-autoload.el 文件执行，预加载一些函数名进 workspace。为什么会有再初始时就有加载 autoload 这一过程呢？
	
	• 请思考如下问题。如果没有 autoload，你可以在 init.el 加载时就 load 各种各样的脚本，使得 emacs 在启动时就把整个使用过程中可能用到的函数一次性准备好。但这样真的好么？
	autoload 告诉 emacs 某个地方有一个定义好的函数，并且告诉 emacs，先别加载，只要记住在调用这个函数时去哪里寻找它的定义即可。这样做的一个好处是，避免在启动 emacs 时因为执行过多代码而效率低下，比如启动慢，卡系统等。想象一下，如果你安装了大量的有关 python 开发的插件，而某次打开 emacs 只是希望写点日记，你肯定不希望这些插件在启动时就被加载，让你白白等上几秒，也不希望这些插件在你做文本编辑时抢占系统资源（内存，CPU 时间等）。所以，一个合理的配置应该是，当你打开某个 python 脚本，或者手动进入 python 的编辑模式时，才加载那些插件.
	
	• autoload 定义的函数都可以直接调用，而不需要 require，like company-mode。所以 autoload 行为的意义用一个简单的概括是：“只注册函数名而不定义函数本身”。
	
它执行过程如下，以 company 为例。在这个 package 安装好后 ，我们可以在.emacs.d/elpa 下看
到 company 文件夹，包含了 company-xxxfunction.el 和一系列自解码.elc 二进制文件，这些
即是 company-mode 的全部执行细节。Emacs 会自动遍历 company-20160325 里面所有文件，提取所有注释里有魔法语句；；;autoload 的内容，并根据这个注释自动生成一个一个的魔法语句块，全部存在 company-autoload.elc 文件里。例如一下魔法语句块就是根据第一行从 company.el 自动生成的：



**** 4.2 Non-autoload

** DONE Installing Source Code Pro in Ubuntu and MS Windows platform 2019 【2019 版 Source Code Pro 字体安装指南】 :@TECH:Ubuntu:
   CLOSED: [2019-09-03 Tue 21:53]
   :PROPERTIES:
   :EXPORT_FILE_NAME: source-code-pro-in-ubuntu-mswindows
   :END:
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2019-09-03 Tue 21:53]
   :END:

#+begin_description 
Installing source code pro and trouble shooting.
#+end_description 

使用 Emacs 的时候，有时候会用到 Source Code Pro 字体，尤其是 Spacemacs 以它作为
默认字体。未安装会造成 Emacs 启动时出现报错。可以使用以下方式安装 2019 年 2.03
版本字体。

*** MS Windows
以下网址给了详细的图片操作步骤：
[[https://simpletutorials.com/c/2759/How+to+install+the+default+Spacemacs+font+on+Windows][Simple Tutorials - htddtps://simpletutorials.com/]]

*** Ubuntu
Linux 下安装，由下载，解压，编译，粘贴，删除源文件等一系列操作组成，所以我附上 shell 脚
本一键操作。
脚本来自：[[https://www.rogerpence.com/posts/install-source-code-pro-font-on-ubuntu][rogerpence.com | Install Source Code Pro font on Ubuntu - https://www.rogerpence.com/]]

【注意】如果手动输入，或者代码报错，文件名称最好使用 =自动补全= 。

1. Home 目录下新建脚本
#+begin_src emacs-lisp
  touch ~/install-source-code-pro.sh
#+end_src
2. 把脚本模式改成可执行文件
#+begin_src elisp
  sudo chmod +x install-source-code-pro.sh
#+end_src
3. 填写脚本内容并保存
#+Begin_src sh
  #!/usr/bin/env bash
  cd Downloads

  wget https://github.com/adobe-fonts/source-code-pro/archive/2.030R-ro/1.050R-it.zip

  if [ ! -d "~/.fonts" ] ; then
  mkdir ~/.fonts
  fi

  unzip 1.050R-it.zip 

  cp source-code-pro-*-it/OTF/*.otf ~/.fonts/
  rm -rf source-code-pro* 
  rm 1.050R-it.zip 

  cd ~/

  fc-cache -f -v
#+end_src

4. 执行脚本
#+begin_src shell
  ./install-source-code-pro.sh
#+end_src

使用愉快:) 
** DONE Using aspell in windows 10 and Emacs 26 above 【拼写检查 Emacs26 使用更新版 aspell】 :@TECH:Emacs:Spacemacs:Windows10:
   CLOSED: [2019-09-13 Fri 01:34]
   :PROPERTIES:
   :EXPORT_FILE_NAME: using-aspell-in-windows-10-and-emacs-26-above
   :END:
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2019-09-13 Fri 01:34]
   :END:
   
 #+begin_description
Installing aspell for Emacs 26+ in windows system.
 #+end_description

I just realized that my ispell doesn't work after updating my Emacs to 27.0
version. I kept getting errors that:
 
 #+begin_src emacs-lisp
aspell release 0.60 or greater is required
 #+end_src

[[https://emacs.stackexchange.com/questions/41892/aspell-with-emacs-26-1-on-ms-windows/45752#45752][flyspell - aspell with emacs 26.1 on ms windows - Emacs Stack Exchange - https://emacs.stackexchange.com/]]

The above discussion shows that by the time being of emacs 26 released, there was no
binary aspell in windows OS, so the workaround was to use hunspell. Now the
=final solution= has been provided by =installing aspell with *Msys2*=.

更新 Emacs 以后发现 aspell 不能用了，调用 ~ispell-minor-mode~ 时一直收到以上报错，查
看以上 stack exchange 的答案发现， 错误原因是 Emacs 26 以上的版本刚发布的时候 windows 还没有与
之匹配的 aspell 安装版本，所
以当时解决方式时暂时用 hunspell 代替。现在，匹配版 aspell 已经发布, 所以下文记录了： =用msys2安装aspell= 。

1. In MingW64 terminal search aspell:
 #+begin_src 
   pacman -Ss aspell
 #+end_src

2. Installing =aspell= and =dictionary you need= :
 #+begin_src
   pacman -S mingw64/mingw-w64-x86_64-aspell
   pacman -S mingw64/mingw-w64-x86_64-aspell-en
 #+end_src

3. Find aspell.exe location with ~which aspell~, e.g. ~C:\msys64\mingw64\bin~ 

4. Update in dotfile. Especially in Spacemacs:
 #+begin_src emacs-lisp
   (add-to-list 'exec-path "C:/msys64/mingw64/bin/")
   (setq ispell-program-name "aspell")
   (setq ispell-personal-dictionary "c:/msys64/mingw64/lib/aspell-0.60/en_GB")
 #+end_src
 
Done.
-----
More awesome (Chinese) articles of spell checking in Emacs, reading with google
translation if needed:

[[http://blog.lujun9972.win/blog/2018/06/03/emacs%E5%B8%AE%E4%BD%A0%E8%BF%9B%E8%A1%8C%E8%8B%B1%E6%96%87%E5%86%99%E4%BD%9C/][Emacs帮你进行英文写作 - 暗无天日 - http://blog.lujun9972.win/]]

[[https://www.hahack.com/tools/ispell-and-flyspell/][ispell与emacs的拼写检查 | HaHack - https://www.hahack.com/]]
** DONE Overview: Emacs line truncation in text editing 【Emacs org 换行/对齐/排版  汇总指南】 :@TECH:Emacs:Org_mode:
   CLOSED: [2019-09-17 Tue 12:53]
   :PROPERTIES:
   :EXPORT_FILE_NAME: emacs-line-truncation-in-text-editing-mode
   :END:
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2019-09-17 Tue 12:53]
   :END:

 #+begin_description
Line visualization and navigation settings in Emacs text editing.
#+end_description

The text line (with line number) in Emacs, is called =logical line= . When a logical
line gets _too long_ in typing window, Emacs provides two distinguish solutions: =line truncation= and =line wrapping= .

*** Common approaches
-----
Here is the link of technicalities of the solutions:

[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Truncation.hrequest json-mode all-the-icons-dired edit-indirecttml][Truncation - GNU Emacs Lisp Reference Manual - https://www.gnu.org/]]

I draw a more straightforward figure:
[[/img/line operation 1.jpg]] 

• The breaked or wrapped line is refered as =screen line=, as opposed to
  =logical line=. Why do we care the
  differences? To precisely control the keybinding navigation between lines. 

• Although the default line setting in Emacs is =wrapping on=, you may want to
  check your local setting with ~C-h m~ to see which exactly major/minor-mode
  you're using before rushing in trying other settings. 

• If you're using =j(or k)= to navigate between lines, check which function it is binded
to. ~evil-next-line~ moves between _logical_ lines. Conventionally this binds to =j= in
evil-mode and VIM. ~evil-next-visual-line~ moves between _screen_ lines. Conventionally this binds to =gj=.  

• Note most other line operation commands act on =logical lines=, NOT screen
lines. For instance, ~C-k~ kills a =logical line=.

• If making MS office word instances: =truncate off= and =text-mode= are like violent _justified on both sides_; =visual-line-mode=
  and =auto-fill-paragraph= are like _left alighned_.

• I personally use =auto-fill-paragraph= with self-setting fill-column to write
  articles, pressing ~M-q~ to arrange lines as I needed. It's neatly fast, coz other automated
  indentation rules are quite complicated and therefore slows your computer.

This may help you decide your configuration:
[[/img/line operation 2.jpg]]

*** More reading
• This code can rearrange wrapped lines to long logical lines：
#+begin_src emacs-lisp
;; unfill paragraph: the opposite of fill-paragraph
(defun y:unfill-paragraph-or-region (&optional region)
  "Takes a multi-line paragraph and makes it into a single line of text."
  (interactive (progn (barf-if-buffer-read-only) '(t)))
  (let ((fill-column (point-max))
        ;; This would override `fill-column' if it's an integer.
        (emacs-lisp-docstring-fill-column t))
    (fill-paragraph nil region)))
(define-key global-map "\M-Q" 'y:unfill-paragraph-or-region)
#+end_src

• More helpful packages about line breaking：

[[https://github.com/davidshepherd7/aggressive-fill-paragraph-mode][davidshepherd7/aggressive-fill-paragraph-mode: An emacs minor-mode for keeping paragraphs filled (in both comments and prose) - https://github.com/]]
** DONE Text based file management in Emacs 【Emacs 文本文件管理】
   CLOSED: [2019-09-22 Sun 23:56]
   :PROPERTIES:
   :EXPORT_FILE_NAME: Text-based-file-management-in-emacs
   :END:
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2019-09-22 Sun 23:56]
   :END:

#+begin_description
Overview of text process tools in org-mode.
#+end_description

People discuss the most efficient way text management methods for a number of reasons: someone wants to build a digitalized notebook for new
knowledge; Someone wants to manage the increasing case files in office work;
Someone wants to archive thousands of articles they hoard on the internet. Either
way, I call that 'text digesting system' or 'personal wiki'. Buckle up, I got
some strong opinions about this topic. 

I think we all have been struggling in choosing tools: some excel at
supporting markdown, some are good at coding highlighting, some support
real-time online collaboration or even text searching in images. If one has not used Emacs, I would probably
recommend Evernote or Onenote. But if you're an Emacs user, this is the chance of
tasting the one-for-all solution.

This image is an =irresponsible, persponal experiece based= summary of tool
learning curve:
[[/img/text.png]]

On *methdological* level, my argument of recommending is that Emacs is the tool
which has the most potential to facilitate you to manage all level of text work:
from a TODO shopping list, to a one-person wikipedia.

On *technical* level, Emacs org-mode meets different needs with all types of
packages. For example:

• To take note speech: input in org-mode

• To memorize knowledge: Anki + Anki-editor

• To classify: categories and tags

• To search: helm-ag + regex

• To visualize structure: Knowledge Graph; Daft; NotDeft; etc.

• To present in slides: Org-reveal

• To generate static website: Hugo + Ox-hugo 

*** 0. General opinion
Although as many merits mentioned above, Emacs is a tool which takes years to
master, so I would NOT recommend converting to Emacs right after watching some
killer demo. Instead, my general opinion about text work is keeping different stage of work in
different places, for non-proficient Emacers.

Firstly, put speedy notes in out-of-boxes softwares in corresponding area
(e.g. put text/snapshot/recordings in Onenote; put R code in Rstudio, put math
paper in Lyx; draw figure in paint) Capturing ideas and finishing work at this
stage is much more important than debugging Emacs. Secondly, constantly
review the work you're managing and do this in Emacs. It will not only help you
to know Emacs, to learn using different backend, but also facilitates you to
extract your own perception out of the hoarded files collected. As a
consequence, this entitles you with one
particular advantage that you will be maintaining a database
of intellectural work on standby for you to present anytime, in an overwhelmingly
good way.  

*** 1. Text search and classification
-----
Softwares like Evernote or Onenote is excellent in most daily work. Skepticism
emerges in three common cases: 1). when there is increasing reptitive text
processing work (e.g. using yasnippet). 2). when there is needs for higher level of efficiency (e.g.
version control, regular expression based search). 3). when there is needs for
variety exporation (e.g.HTML or Latex). These happens regardless of managing
several files or managing over a thousand files, which adds together became the reason that I
moved my text work to Emacs. 

For example, the most common way to manage files
is using categories and tags (or tweaked as pages/binders/etc.) The limitation
of using category is that you can only allocate an article ONCE (what about articles
inherently belong to two or more categories?). The tags seem to
help address this issue, and yet I noticed it's still not enough in practical
work. This is also the reason that people started using some other tools and
switched back to Emacs in the end.


My opinion is that: =the classification of an article should be better decided by the *whole article*,
rather than several keywords.= 
After a long while of managing hundred notes, I noticed the most frequently used (and
efficient) function is =global search =.  I still use categories and tags,but
that's just to maintain my overview of the structure of all articles.

I use =helm-ag=, the silver search which is a searcher reconstructed with C and
it's SO FAST, especially in large files or codes with over 400,000 lines.
The linux command line search tool speed ranks as: =ag > pt > ack > grep=.
Acorrding to requent users, the =ag= search is 5-10 times faster than =ack= on average.

This is my spacemacs config file, which is a big text file tree that I
need to comb through constantly. 
[[/img/searching2.png]]

~M-x helm-ag ("path-to-file")~ enables text search. Without path parameter, it
searches all files under parent file of current buffer. For example,
searching =zilongshanren= in =~/.spacemacs.d/init.el= buffer.  
[[/img/searching3.png]]

*** 2. Structure visualization
-----
Org-mode seems to encourage or intentionally facilitate you organize text
articles in ONE file. For example, all this website is written in one file with
different categories to distinguish taxonomy. All the org-capture facilitated
items such as to-do or blog idea is managed in a single file.

In this case there are lots of software you can use to illustrate the in-file
structure.

Check this:
[[http://ergoemacs.org/misc/mindmap_gantt_graphviz.hrequest json-mode all-the-icons-dired edit-indirecttml][Intro to Mindmap, Gantt Chart, Graphviz - http://ergoemacs.org/]] 

*** 3. Knowledge graph
-----
This is for cases where you want lots of cross-references on files may be in
different directories:

[[https://www.youtube.com/watch?v=R2vX2oZmUUM&feature=youtu.be][Semantic Synchrony, ultrafast video demo - YouTube - https://www.youtube.com/]]
[[https://github.com/synchrony/smsn/wiki/A-video-introduction-to-Semantic-Synchrony][
A video introduction to Semantic Synchrony · synchrony/smsn Wiki -
https://github.com/]]

*** 4. Anki
-----
#+MACRO: color @@HTML:<span style="color:$1">$2</span>
I have written a seperate article of Anki in this blog:

** DONE Using Anki-editor to build flashcard in Emacs Org-mode 【用 Anki-editor 在 Emacs Org-mode 中生成复杂记忆卡片】 :@TECH:windows:org_mode:Anki:Emacs:
   CLOSED: [2019-09-30 Mon 23:54]
   :PROPERTIES:
   :EXPORT_FILE_NAME: using-anki-editor-to-build-flashcard-in-org-mode
   :END:
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2019-09-30 Mon 23:54]
   :END:

*** 1. Anki
-----
One of a major activity in my daily work is to learn new things. I have rely
heavily on paper flashcard which gives me most flexibility on keeping tables, code, math
functions etc. But the shortcoming is pretty obvious: there is no =scientific
reviewing cycle=, and it's getting cumbersome to maintain and carry with.

Then I dived into different softwares and discovered Anki has been exceled in
every aspect that I could ever ask for. Let's see how Anki describe itself:

#+begin_quote
Anki is a program which makes remembering things easy. Because it's a lot more efficient than traditional study methods, you can either greatly decrease your time spent studying, or greatly increase the amount you learn.

Anyone who needs to remember things in their daily life can benefit from Anki. Since it is content-agnostic and supports images, audio, videos and scientific markup (via LaTeX), the possibilities are endless.
For example:

• Learning a language
• Studying for medical and law exams
• Memorizing people's names and faces
• Brushing up on geography
• Mastering long poems
• Even practicing guitar chords!
#+end_quote

However, importing complex content
requires certain hacking of HTML. So the trick is: using org-mode with Emacs
the org HTML export backend will export it to HTML. The Anki adds-on
=AnkiConnect= will generate the ontent to flashcard. 

[[https://apps.ankiweb.net/][Anki - powerful, intelligent flashcards - https://apps.ankiweb.net/]]

*** 2. Installation
-----
The full installation link can be found from github repo:
[[https://github.com/louietan/anki-editor][louietan/anki-editor: Emacs minor mode for making Anki cards with Org - https://github.com/]] 

• Installing =AnkiConnect= in *Anki*: Tools -- adds-on -- Get Add-ons with
code: 2055492159.
[[/img/anki.png]]

• Installing =curl= in *MS Windows*:

There are several ways of applying =curl= in windows: build-in curl, curl in
Msys2, and scoop installed curl. The former two methods always have connecting issues
in Emacs, so my way is to: =delete Msys2 curl and install with scoop.=

• Installing =Anki-editor= in *Emacs*::
 - Vanilla Emacs:
#+begin_src 
(use-package anki-editor
  :ensure t)
#+end_src
 
 - Spacemacs:
#+begin_src 
dotspacemacs-additional-packages '(anki-editor)
#+end_src

*** 3. Usage
-----
First of all, making sure Anki is =running all the time= so that Emacs can connect
with it. =M-x anki-editor-mode= to enable minor-mode.
[[/img/anki2.png]]
Note: 
=Error communicating with AnkiConnect using cURL: exited abnormally with code 2=
means Emacs has trouble finding curl. Check if the path of curl has been added in exec-path.

=Error communicating with AnkiConnect using cURL: exited abnormally with
code 7= 
means you need to run =Anki= before running Emacs command.

The author of Anki-editor has also provided the test cases to play with:

https://raw.githubusercontent.com/louietan/anki-editor/master/examples.org

Here are some cases that I generated:
[[/img/anki3.png]]
** DONE Deduction of Poisson process 【泊松过程推导】 :@MATH:statistics:stochastic_process:probability: 
   CLOSED: [2019-10-15 Tue 02:34]
   :PROPERTIES:
   :EXPORT_FILE_NAME: deduction-of-poisson-process
   :END:
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2019-10-15 Tue 02:34]
   :END:

A straightforward deduction of poisson process.

一份简单明了的泊松过程推导。

*** 1. Reasoning
-----
[[/img/4 poisson 1.jpg]]

[[/img/4 poisson 2.jpg]]

*** 2. Expected value and Variance 
-----
[[/img/4 poisson 3.jpg]]
** DONE Migrating habituated cut copy and paste into Emacs :@TECH:Emacs:Spacemacs:   
   CLOSED: [2019-11-14 Thu 11:40]
   :PROPERTIES:
   :EXPORT_FILE_NAME: foundamentals-about-factorial-experiment-design
   :END:
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2019-11-14 Thu 11:40]
   :END:

In order to get as versitile as possible, I try to avoid re-config keybindings
in different operating environment. I made myself to get used to the
environment, for example there are about four or five different settings in Emacs, VIM,
bash, Windows OS and other terminal. Overall speaking, I find this brings me more benefit than
the cost of learning or migrating customerized config to other environment. In
most cases, it's just *nix (VIM, Emacs) v.s. modern environments (MS, macOS).

In modern system we fix text work with two steps: (1) copy new content (2) mark the
old content and directly paste to replace. But =the old systems do not have
replace function= and this makes the above procedure 3 steps: (1) copy new
content (2)mark the old content and delete (3) paste new content. However the =killing= function is
actually =cutting=: the deleted stuff overwrites the content you were about to
paste in clipboard. (Of course you could press many backspaces in insert-mode to keep the
killing ring/clipboard right but no one really do that) So I found my actual
operation often became more steps (1) I copied new content (2) I marked places
and cut it (3) paste and remembered the clipboard has been overwrote. (4) I went back and re-copied new content (5) I pasted it and got totally
pissed off.

Wether making killing function as cutting is a good design or not, at this point
the best solution is in my opinion is keeping multiple history in clipboard.
Using =helm-show-kill-ring= to keep 5 recent deleted records for your further
concern. This not only frees your mind of remembering the cut/copy operation,
but also save your time for repetitive work.

The alternative choices are =browse-kill-ring= and =counsel-kill-ring-pop=.
** DONE Linear algebra note - Gilbert Strang                          :@MATH:
   CLOSED: [2019-11-19 Tue 23:58]
   :PROPERTIES:
   :EXPORT_FILE_NAME: Linear-algebra-gilbert-strang
   :END:
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2019-11-19 Tue 23:58]
   :END:

This is my personal note of linear algebra. I will be continuously updating the
PDF file. It's kinda huge work, hopefully I can achieving it little by little
everyday. It is hosted on github with latex source code:

https://github.com/QiKatherine/Linear-algebra/blob/master/1.pdf

** DONE The Little Schemer speedy referring note (1/3)                :@TECH:
   CLOSED: [2019-12-10 ÖÜ¶þ 23:20]
   :PROPERTIES:
   :EXPORT_FILE_NAME: The-little-schemer-note
   :END:
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2019-12-10 ÖÜ¶þ 23:20]
   :END:

The Little Schemer uses a very easy way, introducing the nature of recursion,
continuation and Y combinator with only several simple building blocks. You might
have been so used to writing and calling functions with formal name, this book
will show you how complex procedure can be reformed by lambda expressions.

This is a quick reference note that I pull from the book The Little Schemer. The
full detailed code can be found in this repo:

[[https://github.com/pkrumins/the-little-schemer/blob/master/02-do-it-again.ss][the-little-schemer/02-do-it-again.ss at master · pkrumins/the-little-schemer]]


My recommendation of reading this book is that don't skip too much questions
after the fifth chapter, as the functions getting more complex, you will find those
questions from the dialogue are carefully asked, in order to guide us to gradually write a better program. Meanwhile try to write functions with pens and papers before checking the
answer, and often review them with quick scan of this article. I really enjoy this book, and hope you have much fun as I do :).

From some point, you probably need to read "Fibonacci times" in every chapter to fully
understand but keep going, you won't regret it.
 
*** Chapter 1 Toy

 In this chapter, we list primitive conceptions and functions which will be
 used through the entire book:
-----
  *atom* is the smallest element, something NOT enclosed by pair of
  parenthesis: a string of digits/characters/numbers.

  *list* is something enclosed by pair of parenthesis: something can be nothing, can be
  atom, can be another list.
 
  *s-expression* can be an atom, or an expression of the form (x y) where x and
  y are s-expressions. It's essentially a binary tree.

 ~(car argument)~: returns first s-expression among all the first-level
  s-expression within a list. It can NOT work on empty list.

  ~(cdr argument)~: returns the complement set of ~(car argument)~, including
  the parenthesis. It can return empty list but can NOT work on non-list input.

  ~car/cdr~ both take and output non-empty list. ~cdr~ cannot work on null list or
  atom. For ~(han), han, ()~ cdr can only work on the first.

 ~(cons argument1 argument2)~: add arg1 (s-exp) onto arg2 (list), the output is
  list.

 ~(null? argument)~: returns T when the argument(list) is ~(quote()), '() and ()~ returns
  error when argument is ~atom~; returns F for others.
 
 ~(atom? argument)~: checks if the argument (any s-expression) is atom.

 ~(eq? argument1 argument2)~: returns T when arguments (atoms) are equal; returns
  error when arguments are numerical or list; returns F for others.

 ~(or argument1 argument2 ...)~ checks predicate arguments one by one. It terminates
 whenever the first T is found and returns T, otherwise it returns F.

 ~(and argument1 argument2 ...)~ checks predicate arguments one by one. It terminates
 whenever the first F is found and returns F, otherwise it returns T.
*** Chapter 2 Do It Again and Again

From chapter 2, we begin to build functions with primitive building blocks.
-----
 ~(lat? argument)~: checks if every s-expression in a list is atom. Since the
  s-expression is either atom or list/pair, ~(lat?)~ use ~(atom?)~ as core function.
#+begin_src scheme
;define atom? as primitive function first:
(define atom?
 (lambda (x)
    (and (not (pair? x)) (not (null? x))))) 

; (lat? (Jack Sprat could eat no chicken fat)) -> #t, for every element is atom.
(define lat?
  (lambda (l)
    (cond
      ((null? l) #t)
      ((atom? (car l)) (lat? (cdr l)))
      (else #f))))
#+end_src

 ~(member? argument1 argument2)~: checks if the argument1 (an atom) is in
the argument2 (a non-empty list). 
#+begin_src scheme
; (member? meat (mashed potatoes and meat gravy)) -> #t, for meat is in the list.
(define member?
  (lambda (a lat)
    (cond
      ((null? lat) #f)
      (else (or (eq? (car lat) a)
                (member? a (cdr lat)))))))
#+end_src

*** Chapter 3 Cons the Magnificent
-----

 ~(rember argument1 argument2)~: removes the first occurrence of the argument1 (an atom) from
the argument2 (a non-empty list).
#+begin_src scheme
; (rember cup (coffee cup tea cup and hick cup)) -> (coffee tea cup and hick cup)
(define rember
  (lambda (a lat)
    (cond
      ((null? lat) '())
      ((eq? (car lat) a) (cdr lat))
      (else (cons (car lat)
                  (rember a (cdr lat)))))))

#+end_src

~(first argument)~: the argument is a non-empty list, possibly consists of more
lists. The function returns a list consists of all the first s-expressions within
the first level argument lists.
#+begin_src scheme
; (firsts ((five plums) (four) (eleven green oranges))) -> (five four eleven)
(define firsts
  (lambda (l)
    (cond
      ((null? l) '())
      (else
        (cons (car (car l)) (firsts (cdr l)))))))
#+end_src

~(insetR new old lat)~ and ~(insetL new old lat)~: insert the /new/ atom at the
RIGHT/LEFT side of the /old/ atom in lat (a list).
#+begin_src scheme
; (insertR topping fudge (ice cream with fudge for dessert)) -> (ice cream with fudge topping for dessert)
(define insertR
  (lambda (new old lat)
    (cond
      ((null? lat) '())
      ((eq? (car lat) old)
       (cons old (cons new (cdr lat))))
      (else
        (cons (car lat) (insertR new old (cdr lat)))))))

; (insertL topping fudge (ice cream with fudge for dessert)) -> (ice cream with topping fudge for dessert)
(define insertL
  (lambda (new old lat)
    (cond
      ((null? lat) '())
      ((eq? (car lat) old)
       (cons new (cons old (cdr lat))))
      (else
        (cons (car lat) (insertL new old (cdr lat)))))))
#+end_src

~(subst new old lat)~: in lat (a list), this function replaces old atom with new
atom.
~(subst2 new o1 o2 lat)~: in lat (a list), this function checks o1 o2, whichever
occurs firstly is replaced by new atom.

#+begin_src scheme
; (subst topping fudge (ice cream with fudge for dessert)) -> (ice cream with topping for dessert)
  (define subst
    (lambda (new old lat)
      (cond
        ((null? lat) '())
        ((eq? (car lat) old)
         (cons new (cdr lat)))
        (else
          (cons (car lat) (subst new old (cdr lat)))))))

; (subst2 vanilla chocolate banana (banana ice cream with chocolate topping)) -> 
; (vanilla ice cream with chocolate topping)
  (define subst2
    (lambda (new o1 o2 lat)
      (cond
        ((null? lat) '())
        ((or (eq? (car lat) o1) (eq? (car lat) o2))
         (cons new (cdr lat)))
        (else
          (cons (car lat) (subst new o1 o2 (cdr lat)))))))
#+end_src

From now on, we use recursion more than once, in different predicates to achieve
multiple assignments, or more complicated assignments. For example, putting a
recursion in =(eq?)= predicate, in =(rember)= function enables us to go deeper,
removing multiple occurred atoms.
~(multirember a lat)~: removes all the occurrences of a in lat (a list).
~(multiinsertR new old lat)~ and ~(multiinsertL new old lat)~: insert new atom at the
RIGHT/LEFT side of old atom for EVERY occurrence of old in lat (a list).
#+begin_src scheme
; (multirember cup (coffee cup tea cup and hick cup)) -> (coffee tea and hick)
(define multirember
  (lambda (a lat)
    (cond
      ((null? lat) '())
      ((eq? (car lat) a)
       (multirember a (cdr lat)))
      (else
        (cons (car lat) (multirember a (cdr lat)))))))

; (multiinsertR x a (a b c d e a a b)) -> (a x b c d e a x a x b)
(define multiinsertR
  (lambda (new old lat)
    (cond
      ((null? lat) '())
      ((eq? (car lat) old)
       (cons old (cons new (multiinsertR new old (cdr lat)))))
      (else
        (cons (car lat) (multiinsertR new old (cdr lat)))))))

; (multiinsertL x a (a b c d e a a b)) -> (x a b c d e x a x a b)
(define multiinsertL
  (lambda (new old lat)
    (cond
      ((null? lat) '())
      ((eq? (car lat) old)
       (cons new (cons old (multiinsertL new old (cdr lat)))))
      (else
        (cons (car lat) (multiinsertL new old (cdr lat)))))))
#+end_src

~(multirsubst new old lat)~: replaces old atom with new atom for EVERY occurrence
of old atom in lat (a list).
#+begin_src scheme
; (multisubst x a (a b c d e a a b)) -> (x b c d e x x b)
define multisubst
  (lambda (new old lat)
    (cond
      ((null? lat) '())
      ((eq? (car lat) old)
       (cons new (multisubst new old (cdr lat))))
      (else
        (cons (car lat) (multisubst new old (cdr lat)))))))
#+end_src

The multi operation is generally better designed. It can work with both single
and multiple occurrences of old atoms, and terminate at until it's got null
list. But the single operations terminate right when the first ~(eq?)~ returns
T. Generally applicable termination should be at finishing the last element. 

*** Chapter 4 Number Games

To start, we only consider /whole/ and /positive/ number. We are going to
firstly build increment function ~(add1 argument)~, and decrement function
~(sub1 argument)~; then using them as fundamental blocks, we build addition
~(o+)~ and subtraction ~(o-)~; again using addtion as building block, we build multiplication.
It can be sensed that these recursive paradigm is exactly how we establish all more
calculation algorithms.
#+begin_src scheme
;(add1 67) -> 68
(define add1
  (lambda (n) (+ n 1)))

;(sub1 5) -> 4
(define sub1
  (lambda (n) (- n 1)))

;(o+ 46 12) -> 58
(define o+
  (lambda (n m)
    (cond
      ((zero? m) n)
      (else (add1 (o+ n (sub1 m)))))))

;(o- 14 3) -> 11
(define o-
  (lambda (n m)
    (cond
      ((zero? m) n)
      (else (sub1 (o- n (sub1 m)))))))

;(o* 5 3) -> 15              
(define o*
  (lambda (n m)
    (cond
      ((zero? m) 0)
      (else (o+ n (o* n (sub1 m)))))))
#+end_src

Next we introduce new class tuple (tup). *tup* is either an empty list, or it contains a number and a rest that is also a *tup*.

Using tup as building block to create extent function is just as using list before.
To enable natural termination on a list we use ~(null? list)~ and on a number we
use ~(zero? 0)~. To enable the natural termination on a tup we use ~(null? tup)~.

To enable natural recursion on a list we use ~(cdr argument)~; the natural recursion on a
tup we use ~(cdr argument)~; the natural recursion on a number we use ~(sub1
argument)~. These condition is reused as new argument in inner recursion as
stated in The Fourth Commandment.

For tup, we develop two functions for fun:
#+begin_src scheme
;(addtup (3 5 2 8)) -> 18
(define addtup
  (lambda (tup)
    (cond
      ((null? tup) 0)
      (else (o+ (car tup) (addtup (cdr tup)))))))

;(tup+ (3 6 9 11 4) (8 5 2 0 7)) -> (11 11 11 11 11)
(define tup+
  (lambda (tup1 tup2)
    (cond
      ((null? tup1) tup2)
      ((null? tup2) tup1)
      (else
        (cons (o+ (car tup1) (car tup2))
              (tup+ (cdr tup1) (cdr tup2)))))))
#+end_src

The second case shows case need more than one terminal conditions. Using ~(and
(null? tup1) (null? tup2))~ is wrong when tup1 and tup2 have different length.
In such case, we use multiple terminal conditions and it works not only to finish the recursion,
but also to delivery the key result.

Back to the number game, we continuous use the foundamental blocks to creat:
#+begin_src scheme
;(o> 12 133) -> #f 
(define o>
  (lambda (n m)
    (cond
      ((zero? n) #f)
      ((zero? m) #t)
      (else
        (o> (sub1 n) (sub1 m))))))

;(o< 4 6) -> #t
(define o<
  (lambda (n m)
    (cond
      ((zero? m) #f)
      ((zero? n) #t)
      (else
        (o< (sub1 n) (sub1 m))))))

;(o= 5 5) -> #t
(define o=
  (lambda (n m)
    (cond
      ((o> n m) #f)
      ((o< n m) #f)
      (else #t))))

;(o^ 2 3) -> 8
(define o^
  (lambda (n m)
    (cond 
      ((zero? m) 1)
      (else (o* n (o^ n (sub1 m)))))))

;(o/ 15 4) -> 3
(define o/
  (lambda (n m)
    (cond
      ((o< n m) 0)
      (else (add1 (o/ (o- n m) m))))))
#+end_src

In the ~o> and o<~ we can see again that the terminating conditions not only
terminate recursions,
but also work in a carefully arranged order, to deliver the right results for
designated function.

#+begin_src scheme
;(olength (hotdogs with mustard sauerkraut and pickles)) -> 6
(define olength
  (lambda (lat)
    (cond
      ((null? lat) 0)
      (else (add1 (olength (cdr lat)))))))

;(pick 4 (lasagna spaghetti ravioli macaroni meatball)) -> macaroni
(define pick
  (lambda (n lat)
    (cond
      ((zero? (sub1 n)) (car lat))
      (else
        (pick (sub1 n) (cdr lat))))))

;(rempick 3 (hotdogs with hot mustard)) -> (hotdogs with mustard)
(define rempick
  (lambda (n lat)
    (cond
      ((zero? (sub1 n)) (cdr lat))
      (else
        (cons (car lat) (rempick (sub1 n) (cdr lat)))))))
#+end_src

and number
#+begin_src scheme
;(no-nums '(5 pears 6 prunes 9 dates)) -> (pears prunes dates)
(define no-nums
    (lambda (lat)
      (cond
        ((null? lat) '())
        ((number? (car lat)) (no-nums (cdr lat)))
        (else
          (cons (car lat) (no-nums (cdr lat)))))))

;(all-nums '(5 pears 6 prunes 9 dates)) -> (5 6 9)
  (define all-nums
    (lambda (lat)
      (cond
        ((null? lat) '())
        ((number? (car lat)) (cons (car lat) (all-nums (cdr lat))))
        (else
          (all-nums (cdr lat))))))

;(eqan? 'a 'a) -> #t
  (define eqan?
    (lambda (a1 a2)
      (cond
        ((and (number? a1) (number? a2)) (= a1 a2))
        ((or  (number? a1) (number? a2)) #f)
        (else
          (eq? a1 a2)))))

;(occur 'x '(a b x x c d x)) -> 3
  (define occur
    (lambda (a lat)
      (cond
        ((null? lat) 0)
        ((eq? (car lat) a)
         (add1 (occur a (cdr lat))))
        (else
          (occur a (cdr lat))))))

;  (one? 5) -> #f
(define one?
    (lambda (n) (= n 1)))

;(rempick-one 4 '(hotdogs with hot mustard)) -> '(hotdogs with mustard)
(define rempick-one
    (lambda (n lat)
      (cond
        ((one? n) (cdr lat))
        (else
          (cons (car lat) (rempick-one (sub1 n) (cdr lat)))))))

#+end_src

*** Chapter 5 It's Full Of Stars
The starred function family re-write the functions in previous chapters with a
bit more recursions. The purpose is to achieve higher level of
mission, or to make the work more thoroughly.
-----

For example, =(rember a l)= removes multiple occurrences of =a= as the /first level/ s-expression of list =l=, whereas =(rember* a l)= 
removes =a= as /any level/ s-expressions. This is done by changing one more
condition in the outer =(else)= by recusion. We can also improve insertR*,
insertL*, occur*, subst* and member* in the same way.
#+begin_src scheme
; (rember* 'cup '((coffee) cup ((tea) cup) (and (hick)) cup)) 
; -> '((coffee) ((tea)) (and (hick)))
(define rember*
  (lambda (a l)
    (cond
      ((null? l) '())
      ((atom? (car l))
       (cond
         ((eq? (car l) a)
          (rember* a (cdr l)))
         (else
           (cons (car l) (rember* a (cdr l))))))
      (else
        (cons (rember* a (car l)) (rember* a (cdr l)))))))

;(insertR* 'roast 'chuck
;  '((how much (wood)) could ((a (wood) chuck)) (((chuck))) (if (a) ((wood chuck))) could chuck wood))
; -> ((how much (wood)) could ((a (wood) chuck roast)) (((chuck roast)))
(define insertR*
  (lambda (new old l)
    (cond
      ((null? l) '())
      ((atom? (car l))
       (cond
         ((eq? (car l) old)
          (cons old (cons new (insertR* new old (cdr l)))))
         (else
           (cons (car l) (insertR* new old (cdr l))))))
      (else
        (cons (insertR* new old (car l)) (insertR* new old (cdr l)))))))

;(insertL* 'pecker 'chuck
;  '((how much (wood)) could ((a (wood) chuck)) (((chuck))) (if (a) ((wood chuck))) could chuck wood))
; -> ((how much (wood)) could ((a (wood) chuck pecker)) (((chuck pecker))) (if (a) ((wood chuck pecker))) could chuck pecker wood)
(define insertL*
  (lambda (new old l)
    (cond
      ((null? l) '())
      ((atom? (car l))
       (cond
         ((eq? (car l) old)
          (cons new (cons old (insertL* new old (cdr l)))))
         (else
           (cons (car l) (insertL* new old (cdr l))))))
      (else
        (cons (insertL* new old (car l)) (insertL* new old (cdr l)))))))

;(occur* 'banana '((banana) (split ((((banana ice))) (cream (banana)) sherbet)) (banana) (bread) (banana brandy)))
; -> 5
(define occur*
  (lambda (a l)
    (cond
      ((null? l) 0)
      ((atom? (car l))
       (cond
         ((eq? (car l) a)
          (add1 (occur* a (cdr l))))
         (else
           (occur* a (cdr l)))))
      (else
        (+ (occur* a (car l))
           (occur* a (cdr l)))))))

;(subst* 'orange 'banana
;  '((banana) (split ((((banana ice))) (cream (banana)) sherbet)) (banana) (bread) (banana brandy)))
; -> '((orange) (split ((((orange ice))) (cream (orange)) sherbet)) (orange) (bread) (orange brandy))
(define subst*
  (lambda (new old l)
    (cond
      ((null? l) '())
      ((atom? (car l))
       (cond
         ((eq? (car l) old)
          (cons new (subst* new old (cdr l))))
         (else
           (cons (car l) (subst* new old (cdr l))))))
      (else
        (cons (subst* new old (car l)) (subst* new old (cdr l)))))))

;(member 'chips '((potato) (chips ((with) fish) (chips)))) -> #t
(define member*
  (lambda (a l)
    (cond
      ((null? l) #f)
      ((atom? (car l))
       (or (eq? (car l) a)
           (member* a (cdr l))))
      (else
        (or (member* a (car l))
            (member* a (cdr l)))))))
#+end_src
 
The starred functions require more predicates to consider all possibile
situations. After observing the design pattern in the above functions, we
would see that they all asked three fundamental questions: *(1) Is the list null?
(2) If not, is the =(car argument)= an atom? (3) If yes, is the predicate
=(eq?)= true?* It is these questions that enable a
function to work on any cases with: empty list; atom /consed/ to a list; list
/consed/ to a list. 

Let's see another function:
#+begin_src scheme
;(leftmost '((potato) (chips ((with) fish) (chips)))) -> 'potato
(define leftmost
  (lambda (l)
    (cond
      ((atom? (car l)) (car l))
      (else (leftmost (car l))))))
#+end_src
As comparison, this function shows a case where only ONE question is
asked, therefore it works on less types of argument than the starred functions. But
there is more: you may noticed that there were TWO questions checked above. The =(null?)= and =(atom?)=
are achieved by one predicate with some self deducted logic: if the list is null, the =(atom? car(lat))=
would also return F and the recursion in =(else)= will still be called. This type of
simplification will help us to improve functions into a pithy fashion. 

For example, we write =(eqlist?)= to check the equality of two lists. Based on
the 3 golden questions we asked for operating ONE list, designing two lists operation
will require asking 3*3 = 9 predicates (in permutation), and the =(eq?)= is happening when both of the
arguments are atoms:
#+begin_src scheme
;(eqlist? '(strawberry ice cream) '(strawberry ice cream)) -> #t 
(define eqlist?
  (lambda (l1 l2)
    (cond
      ; case 1: l1 is empty, l2 is empty, atom, list 
      ((and (null? l1) (null? l2)) #t)
      ((and (null? l1) (atom? (car l2))) #f)
      ((null? l1) #f); the above predicates have ruled out l2 is empty or list
      ; case 2: l1 is atom, l2 is empty, atom, list 
      ((and (atom? (car l1)) (null? l2)) #f)
      ((and (atom? (car l1)) (atom? (car l2)))
       (and (eq? (car l1) (car l2))
            (eqlist? (cdr l1) (cdr l2))))
      ((atom? (car l1)) #f)
      ; case 3: l1 is a list, l2 is empty, atom, list 
      ((null? l2) #f)
      ((atom? (car l2)) #f)
      (else
        (and (eqlist? (car l1) (car l2))
             (eqlist? (cdr l1) (cdr l2)))))))

;(eqlist2? '(a (b c)) '(a (b c))) -> #t
(define eqlist2?
  (lambda (l1 l2)
    (cond
      ; case 1: l1 is empty, l2 is empty, atom, list
      ((and (null? l1) (null? l2)) #t)
      ((or (null? l1) (null? l2)) #f)
      ; case 2: l1 is atom, l2 is empty, atom, list
      ((and (atom? (car l1)) (atom? (car l2)))
       (and (eq? (car l1) (car l2))
            (eqlist2? (cdr l1) (cdr l2))))
      ((or (atom? (car l1)) (atom? (car l2)))
       #f)
      ; case 3: l1 is a list, l2 is empty, atom, list
      (else
        (and (eqlist2? (car l1) (car l2))
             (eqlist2? (cdr l1) (cdr l2)))))))
#+end_src
Notice that the third predicate can be written as =(null? l1) #f)= because =(cond)= excutes the
predicate one by one. Means that the second predicate gets to run *only when* the
first predicate returns #f which gives us information for inference.  It's not
quite pithy, so in the =(eqlist2?)= we merge some of the redundant #f predicates together
with =(or)=.

This can be further simplified by introducing an S-expression comparison
function =(equal?)=, which itself can be also written in the simplified way as =(eqlist2?)=.
#+begin_src scheme
;(equal? '(a) '(a)) -> #t
(define equal?
  (lambda (s1 s2)
    (cond
      ((and (atom? s1) (atom? s2))
       (eq? s1 s2))
      ((or (atom? s1) (atom? s2)) #f)
      (else (equal? s1 s2)))))

;(eqlist3?
;  '(beef ((sausage)) (and (soda)))
;  '(beef ((salami)) (and (soda)))) -> #f          
(define eqlist3?
  (lambda (l1 l2)
    (cond
      ((and (null? l1) (null? l2)) #t)
      ((or (null? l1) (null? l2)) #f)
      (else
        (and (equal? (car l1) (car l2))
             (equal? (cdr l1) (cdr l2)))))))
#+end_src

After defining =(eqlist?)= to compare the equality of two lists, we can further
improve =(rember)= to remove *lists* as argument, not just removing atoms like in the
previous chapter.
#+begin_src scheme
;(rember '(foo (bar (baz))) '(apples (foo (bar (baz))) oranges)) -> '(apples oranges)
(define rember
  (lambda (s l)
    (cond
      ((null? l) '())
      ((equal2?? (car l) s) (cdr l))
      (else (cons (car l) (rember s (cdr l)))))))
#+end_src
This chapter establish rules to write a good functions =(1) the first thing is to write ALL the operations
for every predicate condition; (2) make sure the algorithm is correct; (3) then to simplify it.=

*** Chapter 6 Shadows
-----
An arithmetic expression (aexp) is either an atom or two arithmetic
expression combined by o+, o* , ^. =(numbered? argument)= return #f if the
argument contains anything other than numbers and o+, o* , ^. 
#+begin_src scheme
;(numbered? '(5 ox (3 'foo 2))) -> #f
(define numbered?
  (lambda (aexp)
    (cond
      ((atom? aexp) (number? aexp))
      ((eq? (car (cdr aexp)) 'o+)
       (and (numbered? (car aexp))
            (numbered? (car (cdr (cdr aexp))))))
      ((eq? (car (cdr aexp)) 'ox)
       (and (numbered? (car aexp))
            (numbered? (car (cdr (cdr aexp))))))
      ((eq? (car (cdr aexp)) 'o^)
       (and (numbered? (car aexp))
            (numbered? (car (cdr (cdr aexp))))))
      (else #f))))

;if we are only allowed to input numeric expression, we can simplify as:
(define numbered?
  (lambda (aexp)
    (cond
      ((atom? aexp) (number? aexp))
      (else
        (and (numbered? (car aexp))
             (numbered? (car (cdr (cdr aexp)))))))))
#+end_src

The function =(value argument)= print the calculated value of a numberic
expression: when the argument is a single atom, it prints itself; when the
argument is conpound, meaning more sub-expressions joint by operator, it
recursively runs until hits a single atom, and then the aggregate calculation is
done from inside to outside. However, notice that the predicate changes according to the syntax
setting of numeric expressions, taking addition as example:
#+begin_src scheme
;(1 + 1) is written as:
 ((eq? (car (cdr nexp)) 'o+)

;(+ 1 1) is written as:
 ((eq? (car nexp) 'o+)
#+end_src
So the =(value)= can be written in two forms:
#+begin_src scheme
;(value '(1 o+ (3 o^ 4))) ->82
  (define value
    (lambda exp)
      (cond
        ((atom? nexp) nexp)
        ((eq? (car (cdr nexp)) 'o+)
         (+ (value (car nexp))
            (value (car (cdr (cdr nexp))))))
        ((eq? (car (cdr nexp)) 'o*)
         (* (value (car nexp))
            (value (car (cdr (cdr nexp))))))
        ((eq? (car (cdr nexp)) 'o^)
         (expt (value (car nexp))
               (value (car (cdr (cdr nexp))))))
        (else #f))))

;(value-prefix '(o+ 1 (o^ 3 4))) -> 82
(define value-prefix
    (lambda (nexp)
      (cond
        ((atom? nexp) nexp)
        ((eq? (car nexp) 'o+)
         (+ (value-prefix (car (cdr nexp)))
            (value-prefix (car (cdr (cdr nexp))))))
        ((eq? (car nexp) 'o*)
         (* (value-prefix (car (cdr nexp)))
            (value-prefix (car (cdr (cdr nexp))))))
        ((eq? (car nexp) 'o^)
         (expt (value-prefix (car (cdr nexp)))
               (value-prefix (car (cdr (cdr nexp))))))
        (else #f))))
#+end_src

For this type of prefixed operator syntax, we can rewrite it with pre-defined
1st and 2nd sub-expressions:
#+begin_src scheme
(define 1st-sub-exp
  (lambda (aexp)
    (car aexp)))

(define 2nd-sub-exp
  (lambda (aexp)
    (car (cdr (cdr aexp)))))

(define operator
  (lambda (aexp)
    (car (cdr aexp))))

(define value-prefix-helper
  (lambda (nexp)
    (cond
      ((atom? nexp) nexp)
      ((eq? (operator nexp) 'o+)
       (+ (value-prefix (1st-sub-exp nexp))
          (value-prefix (2nd-sub-exp nexp))))
      ((eq? (car nexp) 'o*)
       (* (value-prefix (1st-sub-exp nexp))
          (value-prefix (2nd-sub-exp nexp))))
      ((eq? (car nexp) 'o^)
       (expt (value-prefix (1st-sub-exp nexp))
             (value-prefix (2nd-sub-exp nexp))))
      (else #f))))
#+end_src

From this chapter we begin to *design different functions for different syntax
setting functions*, we know this work will not be limited to =(1 + 1) and (+1
1)=. Actually, the syntactic/symbolic expression can be in any form, such as: if
0 is written as =quote()=, then 4 can be written as =(() () () ()) or
((((()))))=. Accordingly, the numberic operations can be written as:
#+begin_src scheme
; sero? just like zero?
(define sero?
  (lambda (n)
    (null? n)))

; edd1 just like add1
(define edd1
  (lambda (n)
    (cons '() n)))

; zub1 just like sub1
(define zub1
  (lambda (n)
    (cdr n)))

; .+ just like o+
;(.+ '(()) '(() ())) -> '(() () ())
(define .+
  (lambda (n m)
    (cond
      ((sero? m) n)
      (else
        (edd1 (.+ n (zub1 m)))))))

; tat? just like lat?
;(tat? '((()) (()()) (()()()))) -> #f
(define tat?
  (lambda (l)
    (cond
      ((null? l) #t)
      ((atom? (car l))
       (tat? (cdr l)))
      (else #f))))
#+end_src

** DONE The Little Schemer speedy referring note (2/3)                :@TECH:
   CLOSED: [2019-12-23 Mon 01:35]
   :PROPERTIES:
   :EXPORT_FILE_NAME: The-little-schemer-note-2-3
   :END:
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2019-12-23 Mon 01:35]
   :END:

This is a quick reference note that I pull from the book The Little Schemer. The
full detailed code can be found:

[[https://github.com/pkrumins/the-little-schemer/blob/master/02-do-it-again.ss][the-little-schemer/02-do-it-again.ss at master · pkrumins/the-little-schemer]]


*** Chapter 7 Friend and Relations
-----

In this chapter, we see more examples of using the previously defined functions
to develop more functions.

*set* is a list consists of *non-repeated* atoms. The function =(set? argument)=
 checks whether a list is a set. It can be written with =(member?)=:
#+begin_src scheme
  (define member?
    (lambda (a lat)
      (cond
        ((null? lat) #f)
        (else (or (eq? (car lat) a)
                  (member? a (cdr lat)))))))

;(set? '(apple 3 pear 4 9 apple 3 4)) -> #f
  (define set?
    (lambda (lat)
      (cond
        ((null? lat) #t)
        ((member? (car lat) (cdr lat)) #f)
        (else
          (set? (cdr lat))))))
#+end_src

=(makeset argument)= make a new list by removing duplicated atoms in argument
list. For a repeated atom in list, in order to retain the first occurrence while remove others, we use =(multirember)=: 
 #+begin_src scheme
(define multirember
  (lambda (a lat)
    (cond
      ((null? lat) '())
      ((eq? (car lat) a)
       (multirember a (cdr lat)))
      (else
        (cons (car lat) (multirember a (cdr lat)))))))

;(makeset '(apple 3 pear 4 9 apple 3 4))
(define makeset
  (lambda (lat)
    (cond
      ((null? lat) '())
      (else
        (cons (car lat)
              (makeset (multirember (car lat) (cdr lat))))))))
 #+end_src

For sets, we can define some primary functions: =(subset? argument1 argument2)=
checks whether argument1 is a subset of argument2. =(eqset?= and =(intersect?)= check for
equality and intersection respectively. Comparing the three algorithms, we can
find how the different mathmatical functions can be achieved by manipulating the logical tools. 
#+begin_src scheme
; (subset? '(4 pounds of horseradish)
; '(four pounds of chicken and 5 ounces of horseradish)) -> #f
(define subset?
    (lambda (set1 set2)
      (cond
        ((null? set1) #t)
        (else (and (member? (car set1) set2)
                   (subset? (cdr set1) set2))))))

;(eqset? '(a b c) '(a b)) -> #f
  (define eqset?
    (lambda (set1 set2)
      (and (subset? set1 set2)
           (subset? set2 set1))))

;(intersect? '(stewed tomatoes and macaroni) '(macaroni and cheese)) -> #t
  (define intersect?
    (lambda (set1 set2)
      (cond
        ((null? set1) #f)
        (else (or (member? (car set1) set2)
                  (intersect? (cdr set1) set2))))))
#+end_src

The below functions do a bit more, they return intersection or union or difference results as
 *set* out of the arguments sets.
#+begin_src scheme
;(intersect '(stewed tomatoes and macaroni) '(macaroni and cheese)) -> '(and macaroni)
(define intersect
  (lambda (set1 set2)
      (cond
        ((null? set1) '())
        ((member? (car set1) set2)
         (cons (car set1) (intersect (cdr set1) set2)))
        (else
          (intersect (cdr set1) set2)))))

;(union '(stewed tomatoes and macaroni casserole) '(macaroni and cheese))
; -> '(stewed tomatoes casserole macaroni and cheese)
(define union
   (lambda (set1 set2)
      (cond
        ((null? set1) set2)
        ((member? (car set1) set2)
         (union (cdr set1) set2))
        (else (cons (car set1) (union (cdr set1) set2))))))

;(xxx '(a b c) '(a b d e f)) -> '(c)
(define xxx
  (lambda (set1 set2)
    (cond
      ((null? set1) '())
      ((member? (car set1) set2)
       (xxx (cdr set1) set2))
      (else
        (cons (car set1) (xxx (cdr set1) set2))))))

;(intersectall '((a b c) (c a d e) (e f g h a b))) -> '(a)
(define intersectall
  (lambda (l-set)
    (cond
      ((null? (cdr l-set)) (car l-set))
      (else
        (intersect (car l-set) (intersectall (cdr l-set)))))))
#+end_src

The *pair* is a list with only TWO s-expressions and the *rel* is a set of
pairs. We use =(set?)= and =(firsts)= to define =(fun?)=, which is used to test
whether =(firsts argument)= is a set.(i.e. whether a list consisting of all first
element of first-level sub-expressions contains duplicated atom). 
#+begin_src scheme
(define set?
      (lambda (lat)
        (cond
          ((null? lat) #t)
          ((member? (car lat) (cdr lat)) #f)
          (else
            (set? (cdr lat)))))

(define firsts
  (lambda (l)
    (cond
      ((null? l) '())
      (else
        (cons (car (car l)) (firsts (cdr l))))))

;(fun? '((4 3) (4 2) (7 6) (6 2) (3 4))) -> #f
;(fun? '((8 3) (4 2) (7 6) (6 2) (3 4))) -> #t
(define fun?
  (lambda (rel)
    (set? (firsts rel))))
#+end_src

A list of pairs in which no *first* element of any pair is the same as any other
*first* element, is call a *finite function*; a list of pairs in which no *second*
element of any pair is the same as any other *second* element, is call a
*fullfun*. 

Think about how these two conceptions are connected. For example, we introduce
=(revrel)= to switch each atoms for every pair within a list.
#+begin_src scheme
;(revrel '((8 a) (pumpkin pie) (got sick))) -> '((a 8) (pie pumpkin) (sick got))
(define revrel
  (lambda (rel)
    (cond
      ((null? rel) '())
      (else (cons (build (second (car rel))
                         (first (car rel)))
                  (revrel (cdr rel)))))))

;introducing revpair to simplify revrel
(define revpair
  (lambda (p)
    (build (second p) (first p))))

(define revrel
  (lambda (rel)
    (cond
      ((null? rel) '())
      (else (cons (revpair (car rel)) (revrel (cdr rel)))))))
#+end_src

Naturally, we could define =(seconds)= as we define =(firsts)= to develop
=(fullfun?)= for detecting duplicated second atom.
#+begin_src scheme
(define seconds
  (lambda (l)
    (cond
      ((null? l) '())
      (else
        (cons (second (car l)) (seconds (cdr l)))))))

;(fullfun? '((8 3) (4 2) (7 6) (6 2) (3 4))) -> #f
;(fullfun? '((8 3) (4 8) (7 6) (6 2) (3 4))) -> #t
(define fullfun?
  (lambda (fun)
    (set? (seconds fun))))
#+end_src

But, with the help of =(revrel)=, we can define =(fullfun?)= in a better way.
Let's call it =(one-to-one?)=:
#+begin_src scheme
;(one-to-one? '((chocolate chip) (doughy cookie))) -> #t
(define one-to-one?
  (lambda (fun)
    (fun? (revrel fun))))
#+end_src

*** Chapter 8 Lambda and the Ultimate

In the previous chapters, we've seen over and over that a function takes *list
or atom* as input and returns *list or atom* as output. In this chapter, we
will be learning how to write a function that takes input and returns
*functions*. Technically, a digit/atom is a function too, which takes itself as
argument and returns itself. Taking an naive example, the =(eq?-f)= is a
functional projection which takes =a= (a constant function) as argument and
returns =(eq?-a)= (equivelent in concept) as output. It's called currying. 
#+begin_src scheme
(define eq?-f)
 (lambda (a)
   (lambda (x)
    (eq? x a))))

(define eq?-a
 (lambda (x)
  (eq? x a))
#+end_src

But the functional projection is sometimes more confusing when there are
recursions involved in multiple stages, especially we will no longer spercify
whether every input is an argument or an function. Therefore it will always be beneficial to ask yourself, which functions has been
previously defined, and how its default arguments are tweaked in developing the
current function. 
Let's improve it a little with a familiar function:
#+begin_src scheme
(define rember-f
  (lambda (test?)
    (lambda (a l)
      (cond
        ((null? l) '())
        ((test? (car l) a) (cdr l))
        (else
          (cons (car l) ((rember-f test?) a (cdr l))))))))

; the test? can be eq? equal? eqan? eqlist? eqpair? 
; depending on which type of member you plan to remove.
;e.g. remove number: ((rember-f eq?) 2 '(1 2 3 4 5)) -> '(1 3 4 5)
#+end_src
Notice that this is not a well defined function yet, since we have not
specify the mapping relations. But it can lead us think that =test?= is an equivalent of =a= in the first
example, i.e. a function =(test?)= works as an argument input in function
=(rember-f)=, which together returns a member-removing function as result. This
came because we can find that in =(rember)= function family, whether we want to remove atom
or number or pair or list, the only different part is the equality checking.

It's therefore natural that we want to deconstruct a compound function as
invariant functions + variant function, which allows us to extend more functions efficiently.
Because there are lots of commonly used building blocks in developing algorithms and with currying, we get to write much less repetitive code.

For example, when defining =(insertL)= and =(insertR)=, we notice that the only
difference is the order we =cons= the /new/ and /old/ argument, which can be
isolated as another two small variant functions, and then combined to a main,
invariant function:
#+begin_src scheme
;variant functions
(define seqL
  (lambda (new old l)
      (cons new (cons old l))))

(define seqR
  (lambda (new old l)
      (cons old (cons new l))))

;invariant function containing seq as an abstract place holder
(define insert-g
  (lambda (seq)
      (lambda (new old l)
        (cond
          ((null? l) '())
          ((eq? (car l) old)
           (seq new old (cdr l)))
          (else
            (cons (car l) ((insert-g seq) new old (cdr l))))))))

;compound function
(define insertL (insert-g seqL))

(define insertR (insert-g seqR))
#+end_src

The substitution function only differs in the same position, so it can be
rewritten as:
#+begin_src scheme
;recap subst
(define subst
  (lambda (new old l)
    (cond
      ((null? l) '())
      ((eq? (car l) old)
       (cons new (cdr l)))
      (else
        (cons (car l) (subst new old (cdr l)))))))

;firstly we define variant function
(define seqS
  (lambda (new old l)
    (cons new l)))

;rewrite invariant function accordingly
(define subst-f
 (lambda (seq)
  (lambda (new old l)
    (cond
      ((null? l) '())
      ((eq? (car l) old)
       (seq new old cdr(l)))
      (else
        (cons (car l) (subst-f new old (cdr l)))))))

;huh! the subst-f is identical to insert-g, so we can write as:
(define subst (insert-g seqS))
#+end_src

The =(rember)= function can be achieved by =(insert-g)= too, but it requires
extra tweak, since the =(rember)= doesn't use arguments /new/. The =(seqrem)=
function replaces the old seq's job: it neither cons on left nor right, but only
retains the third argument, aka =(cdr l)=. 
#+begin_src scheme
;invariant function with seqrem as place holder
(define yyy
  (lambda (a l)
    ((insert-g seqrem) #f a l)))

(define insert-g
  (lambda (seq)
      (lambda (new old l)
        (cond
          ((null? l) '())
          ((eq? (car l) old)
           (seq new old (cdr l)))
          (else
            (cons (car l) ((insert-g seq) new old (cdr l))))))))

(define seqrem
  (lambda (new old l)
    l))
;(yyy 'sausage '(pizza with sausage and bacon)) -> '(pizza with and bacon)
#+end_src

Let's see a function with more and more isolated parts to decrease repetitive
work in writting functions. In the =(value)=, we've used 1st-sub-ex and 2nd-sub-exp to write
less /car/ and /cdr/. Here we isolate two more parts =operator= to *locate* the
calculation operator and =atom-to-function= to *match and export* the
calculation operator. Notice that genetically the arguments are named as =aexp=
and =atom= inside the functions, but when they are called in =(value-f)=, the
arguments are tweaked with the arguments of =(value-f)=. 
#+begin_src scheme
;value uses 1st-sub-exp
(define 1st-sub-exp
  (lambda (aexp)
    (car (cdr aexp))))

;value uses 2nd-sub-exp
(define 2nd-sub-exp
  (lambda (aexp)
    (car (cdr (cdr aexp)))))

;atom-to-function uses operator
(define operator
  (lambda (aexp)
    (car aexp)))

;half abstracted function
(define value
  (lambda (nexp)
    (cond
      ((atom? nexp) nexp)
      ((eq? (operator nexp) 'o+)
       (+ (value-prefix (1st-sub-exp nexp))
          (value (2nd-sub-exp nexp))))
      ((eq? (car nexp) 'o*)
       (* (value (1st-sub-exp nexp))
          (value (2nd-sub-exp nexp))))
      ((eq? (car nexp) 'o^)
       (expt (value (1st-sub-exp nexp))
             (value (2nd-sub-exp nexp))))
      (else #f))))

;keep abstract it with what we learned in this chapter
(define atom-to-function
  (lambda (atom)
    (cond
      ((eq? atom 'o+) +)
      ((eq? atom 'o*) *)
      ((eq? atom 'o^) expt)
      (else #f))))

;(value-f '(o+ 1 (o^ 3 4))) -> 82
(define value-f
  (lambda (nexp)
    (cond
      ((atom? nexp) nexp)
      (else
        ((atom-to-function (operator nexp))
         (value-f (1st-sub-exp nexp))
         (value-f (2nd-sub-exp nexp)))))))
#+end_src

Here is another compound function containing more layers of abstractions, which
doesn't only call other functions, but also contains recursions on multiple conditions:
#+begin_src scheme
(define multiremember&co
 (lambda (a lat col)
    (cond
      ((null? lat)
       (col '() '()))
      ((eq? (car lat) a)
       (multiremember&co a (cdr lat)
       (lambda (newlat seen)
         (col newlat (cons (car lat) seen)))))
      (else
        (multiremember&co a (cdr lat)
                          (lambda (newlat seen)
                            (col (cons (car lat) newlat) seen)))))))

(define a-friend
 (lambda (x y)
  (null? y)))
;(multiremember&co 'tuna '() a-friend) -> #t;
;(multiremember&co 'tuna '(tuna) a-friend) -> #f

;(multiremember&co 'tuna '(and tuna) a-friend) -> #f
;in the final recursion, it gets us:
;a=tuna
;lat='()
;col=
;((lambda (newlat1 seen1)
;   ((lambda (newlat2 seen2)
;      (list newlat2 (cons 'foo seen2)))
;    (cons 'bar newlat1)
;    seen1))
; '() '())

;define a different continuation
(define last-friend
 (lambda (x y)
  (length? x)))
;(multiremember&co 'tuna (strawberries tuna and swordfish) last-friend) -> 3
#+end_src
The question has been also discussed on SO: [[https://stackoverflow.com/questions/7004636/explain-the-continuation-example-on-p-137-of-the-little-schemer][recursion - Explain the
continuation example on p.137 of The Little Schemer - Stack Overflow]]

#+begin_src scheme
(define multiinsertLR
  (lambda (new oldL oldR lat)
    (cond
      ((null? lat) '())
      ((eq? (car lat) oldL)
       (cons new
             (cons oldL
                   (multiinsertLR new oldL oldR (cdr lat)))))
      ((eq? (car lat) oldR)
       (cons oldR
             (cons new
                   (multiinsertLR new oldL oldR (cdr lat)))))
      (else
        (cons
          (car lat)
          (multiinsertLR new oldL oldR (cdr lat)))))))

(define multiinsertLR&co
  (lambda (new oldL oldR lat col)
    (cond
      ((null? lat)
       (col '() 0 0))
      ((eq? (car lat) oldL)
       (multiinsertLR&co new oldL oldR (cdr lat)
                         (lambda (newlat L R)
                           (col (cons new (cons oldL newlat))
                                (+ 1 L) R))))
      ((eq? (car lat) oldR)
       (multiinsertLR&co new oldL oldR (cdr lat)
                         (lambda (newlat L R)
                           (col (cons oldR (cons new newlat))
                                L (+ 1 R)))))
      (else
        (multiinsertLR&co new oldL oldR (cdr lat)
                          (lambda (newlat L R)
                            (col (cons (car lat) newlat)
                                 L R)))))))
;some collectors
(define col1
  (lambda (lat L R)
    lat))
(define col2
  (lambda (lat L R)
    L))
(define col3
  (lambda (lat L R)
    R))

; Examples of multiinsertLR&co
(multiinsertLR&co 'salty 'fish 'chips '(chips and fish or fish and chips)  col1)
;-> '(chips salty and salty fish or salty fish and chips salty)
(multiinsertLR&co  'salty  'fish  'chips  '(chips and fish or fish and chips)  col2)
;-> 2
(multiinsertLR&co  'salty 'fish 'chips '(chips and fish or fish and chips) col3)
;-> 2
#+end_src

#+begin_src scheme
;(evens-only* '((9 1 2 8) 3 10 ((9 9) 7 6) 2)) -> '((2 8) 10 (() 6) 2)
(define evens-only*
  (lambda (l)
    (cond
      ((null? l) '())
      ((atom? (car l))
       (cond
         ((even? (car l))
          (cons (car l)
                (evens-only* (cdr l))))
         (else
           (evens-only* (cdr l)))))
      (else
        (cons (evens-only* (car l))
              (evens-only* (cdr l)))))))

;define *&co function
(define evens-only*&co
  (lambda (l col)
    (cond
      ((null? l)
       (col '() 1 0))
      ((atom? (car l))
       (cond
         ((even? (car l))
          (evens-only*&co (cdr l)
                          (lambda (newl p s)
                            (col (cons (car l) newl) (* (car l) p) s))))
         (else
           (evens-only*&co (cdr l)
                           (lambda (newl p s)
                             (col newl p (+ (car l) s)))))))
      (else
        (evens-only*&co (car l)
                        (lambda (al ap as)
                          (evens-only*&co (cdr l)
                                          (lambda (dl dp ds)
                                            (col (cons al dl)
                                                 (* ap dp)
                                                 (+ as ds))))))))))
(define evens-friend
  (lambda (e p s)
    e))

;(evens-only*&co '((9 1 2 8) 3 10 ((9 9) 7 6) 2) evens-friend)
; -> '((2 8) 10 (() 6) 2)
#+end_src
** DONE The Little Schemer speedy referring note (3/3)                :@TECH:
   :PROPERTIES:
   :EXPORT_FILE_NAME: The-little-schemer-note-3-3
   :END:
   :LOGBOOK:
   - State "DONE"       from "DONE"       [2020-01-06 Mon 01:56]
   :END:

The former chapters can be easily understood from reading the code without
counting parenthesis. *However from this chapter, it is highly recommended to
download Drracket and use a stepper to run all the recurions.* For example, the
stepper make the answer of =soegaard= very straightforward:

[[https://stackoverflow.com/questions/10499514/y-combinator-discussion-in-the-little-schemer?noredirect=1&lq=1][scheme - Y combinator discussion in "The Little Schemer" - Stack Overflow]]

This chapter introduces the idea of Y combinator based on recursion. We've seen
that recursion is a function calling itself during defining itself, but when the
function is just an lambda expression without name, what do we do?

The Y combinator provides a solution by designing an high order function, which
is a function that takes a function as an argument and returns a function.
Taking factorial as an example, we deduce a function G where G(factorial)=factorial.
Let's learn how to deduce step by step.
 
*** Chapter 9 and Again and Again and Again
The key of writing recursion is making sure there is =termination condition=.
That's the basic requirement for function in both computation and mathmatics
area: a function is a mapping procedure which takes in an argument and produces
an output accordingly. We need to aviod any algorithm leading to infinite loop.
 
Here is an example of failed design: the =(keep-looking)= calls =(pick)= to see if =a= is equal to the random atom in lat (assuming the numbers in lat is random).
#+begin_src scheme
;pick return n-th element in lat:
(define pick
  (lambda (n lat)
    (cond
      ((zero? (sub1 n)) (car lat))
      (else
        (pick (sub1 n) (cdr lat))))))

(define keep-looking
  (lambda (a sorn lat)
    (cond
      ((number? sorn)
       (keep-looking a (pick sorn lat) lat))
      (else (eq? sorn a )))))

(define looking
  (lambda (a lat)
    (keep-looking a (pick 1 lat) lat)))

; Example of looking
(looking 'caviar '(6 2 4 caviar 5 7 3))         ; #t
(looking 'caviar '(6 2 grits caviar 5 7 3))     ; #f
#+end_src
In the first test case we can find that, the ='caviar= is the 4th element in the
first example, and the list contains 4. So running it is very likely to hit the
termination condition. But in second example the ='caviar= is the 4th element whereas no 4
is contained in the list, so the recursion will run forever, meaning the
function won't always return a value for an input. This illed function is called
*partial function* as opposed to *total function* defined previously. 

Let's see another example. We've defined *pair* is a list containing two
s-expressions (s-expression: a binary tree). The =shift= takes a pair whose first component is a pair and builds a pair by shifting the second part of the first component into
the second component.
#+begin_src scheme
(define first
  (lambda (p)
    (car p)))

(define second
  (lambda (p)
    (car (cdr p))))

(define build
  (lambda (s1 s2)
    (cons s1 (cons s2 '()))))

;(shift '((a b) c)) -> '(a (b c))
;(shift '((a b) (c d))) -> '(a (b (c d)))
(define shift
  (lambda (pair)
    (build (first (first pair))
      (build (second (first pair))
        (second pair)))))

(define a-pair?
  (lambda (x)
    (cond
      ((atom? x) #f)
      ((null? x) #f)
      ((null? (cdr x)) #f)
      ((null? (cdr (cdr x))) #t)
      (else #f))))

(define align
  (lambda (pora)
    (cond
      ((atom? pora) pora)
      ((a-pair? (first pora))
       (align (shift pora))) ;******alarming
      (else (build (first pora)
              (align (second pora)))))))

#+end_src
Based on =(shift)= we further creat =(align)=. Don't rush to run the function. Remember the seventh commandment emphasizes "*recursion should happen on the subparts that are of the same nature:
 either on the sublists of a list; or on the subexpressions of an arithmetic
 expression*". We  notice something alarming in the starred line in =(align)=:
 the =(align)= as well as =(keep-looking)= both creat new argument in recursion
 that is *not part* of the original argument. It's an indicator of ill, but
 =(align)= will still generate output for every input, so it's not  partial function.

We will continue and define a very similar function =(shuffle)= below, which is partial. It won't
produce value for some cases, since the =a-pair= predicate will always swap the items of pair, which
makes any input with form of =((a b) (c d))= trapped in infinite item swapping loop.
#+begin_src scheme
;(revpair '((a b) (c d))) -> ((c d) (a b))
(define revpair
  (lambda (p)
    (build (second p) (first p))))  

(define shuffle
  (lambda (pora)
    (cond
      ((atom? pora) pora)
      ((a-pair? (first pora))
       (shuffle (revpair pora)))
      (else
        (build (first pora)
          (shuffle (second pora)))))))

(shuffle '(a (b c)))        ; '(a (b c))
(shuffle '(a b))            ; '(a b)
(shuffle '((a b) (c d)))    ; infinite swap pora  Ctrl + c  to break and input q to exit
#+end_src
-----
This seems unrelated to the above issue so far. We just define two different
ways to measure the mass of the first component of =(align)=. The =(length*)= measures every
atom with same weight, whereas the =(weight*)= puts twice as much weight to the first component. 
#+begin_src scheme
(define length*
  (lambda (pora)
    (cond
      ((atom? pora) 1)
      (else
        (+ (length* (first pora))
           (length* (second pora)))))))
;(length* '((a b) c)) -> 3
;(length* '(a (b c)) -> 3

(define weight*
  (lambda (pora)
    (cond
      ((atom? pora) 1)
      (else
        (+ (* (weight* (first pora)) 2)
           (weight* (second pora)))))))
;(weight* '((a b) c)) -> 7
;(weight* '(a (b c)) -> 5
#+end_src
-----
From =(align)= and =(shuffle)=, we realize that whether the arguments will
decrease in recursion is not the key to infer whether a function is total. We
start to think if possible to develop a diagnose function to detect the partial function. Let's make
up a function =(will-stop?)= without getting into detail. We want it to *return
#t if the argument stops when applied to null input, and return #f it does not
stop when inputting null input*. And
itself has to be a total function. Then we try compounding it with =(length)= and =(eternity)= respectively.  
#+begin_src scheme
(define will-stop?
 (lambda (f))
...)

(define length
  (lambda (lat)
    (cond
      ((null? lat) 0)
      (else (add1 (length (cdr lat)))))

(define will-stop?
  (lambda (x)
    (length x)))

(define eternity
  (lambda (x)
    (eternity x)))

(define will-stop?
  (lambda (x)
    (eternity x)))
#+end_src
The =(length)= stops when the input is ='()=, so the =(will-stop?)= returns #t.
But the =(eternity)= is partial and won't stop for any input, which makes the
=(will-stop?)= returns #f whatsoever. This gives us a gist of what function we want
to build. Let's see another tool function:
#+begin_src scheme
(define last-try
 (lambda (x)
  (and (will-stop? last-try)
    (eternity x))))
#+end_src
In order to test if ths is a right function, we input =()= and that requires
evaluate =(will-stop? last-try)=. Provided it returns #f (aka the last-try will
not stop with null input), then the whole function will stop and return #f.
Clearly this mother function =(last-try (quote()))= stops for null input, which
goes against the aka part in parenthesis. So we try the opposite hypothesis: it
returns #t (aka the last-try will stop with null input), and then we get to
evaluate =(eternity (quote()))=, which never stops. And this time, it logically
goes against the hypothesis again. This makes the =(will-stop?)= a
function we can describe but can not define. So be careful when using the recursion.
-----
From now on, we start to learn to remove =(define function-name)= and use lambda
expression to directly refer to a function. This allows us to save time when we
want to quickly define something without permanently store it in official
environment. 

To start, try understand the below two functions are identical, and try writing a
named funtion in lambda expression yourself.
#+begin_src scheme
(define length
 (lambda (l)
  (cond
    ((null? l) 0)
    (else
      (add1 (length (cdr l)))))))

(lambda (l)
  (cond
    ((null? l) 0)
    (else
      (add1 (length (cdr l))))))
#+end_src
It's absolutely normal to get confused when there are more layers of lambda expressions involved in a
function/recursion. It helps to think whether the lambda expressions is being
merely defined or being defined and called, i.e. counting the parenthesis very
carefully. The difference between defining and calling is that calling a function has arguments involved:
#+begin_src scheme
;defining
(lambda (f)
  (lambda (g)...)
)

;calling(f) with defining(g)
((lambda (f)
  (lambda (g)...))
    arguments-for-f)
#+end_src
A more general case of calling with defining in lambda expression is called the
omega combinator. It has shape in the below picture and more information can be
found at [[https://en.wikipedia.org/wiki/Lambda_calculus#Standard_terms][Lambda calculus - Wikipedia]]
[[../static/img/little2.png]]


As you read more, you will understand
the below example is carefully selected: it achieves a simple job at a time; applying
it on itself is achieving a simple job on a achieved job; when repeating calling itself,
it can achieve a almost infinite loop.

In addition, the function change =(length)= a little by calling =(eternity)=
instead of =(length)= in its recursion. This makes the function only works on *null input*, since it will terminate in the =(null?)= predicate without calling the partial
=(eternity)=, otherwise any non-null input will trigger the infinite
recursion and cause failure by giving no answer. This is essentially how the =(length<=0)= can *only* determine the length of the empty list. With it, we can further develop an =(length<=1)= which measures the length of list
with less than one element: 
#+begin_src scheme
;length<=0
(lambda (l)
    (cond
      ((null? l) 0)
      (else
        (add1 (eternity (cdr l))))))

;length<=1
(lambda (l)
  (cond
    ((null? l) 0)
    (else
      (add1 (length0 (cdr l))))))

;length<=1
(lambda (l)  ;read more details below if you don't understand here            
  (cond
    ((null? l) 0)
    (else
      (add1
        ((lambda(l)
           (cond
             ((null? l) 0)
             (else
               (add1 (eternity (cdr l))))))
         (cdr l))))))
#+end_src
[[/img/length1.png]]

Recursively we can develop =(length<=2)= below. Notice these
three functions are identical. (here we start dumping =(define ...)=, referring the
length0 and length1 are there only for demonstration purpose).
#+begin_src scheme
;length<=2
(lambda (l)
  (cond
    ((null? l) 0)
    (else
      (add1 (length1 (cdr l))))))

(lambda (l)
  (cond
    ((null? l) 0)
    (else
      (add1
        ((lambda(l)
           (cond
             ((null? l) 0)
             (else
               (add1 (length0 (cdr l)))))) 
         (cdr l)))))) 

(lambda (l)
  (cond
    ((null? l) 0)
    (else
      (add1
        ((lambda(l)
           (cond
             ((null? l) 0)
             (else
               (add1 
                ((lambda(l)
                 (cond
                   ((null? l) 0) 
                     (else
                       (add1 (eternity (cdr l))))))
               (cdr l))))))
      (cdr l))))))

;let's give distinguished names to arguments in every layer
(lambda (l2)  ;assume l2 = '(b c)
  (cond
    ((null? l2) 0)
    (else
      (add1
        ((lambda(l1)  ;then l1 <- cdr(l2) = '(c)
           (cond
             ((null? l1) 0)
             (else
               (add1 
                ((lambda(l0)  ;then l0 <- cdr(l1) = '( )
                 (cond
                   ((null? l0) 0)  ;so here returns 0, and terminates
                     (else
                       (add1 (eternity (cdr l0))))))
               (cdr l1))))))
      (cdr l2))))))  
#+end_src
The above functions show repetitive content, aka the =(length)= part is being
called over and over, working on a shorter and shorter argument. Normally, we would write and save as a named
function for calling in the future. *But, if we don't save it, instead we want to directly
address it within other function, or even address itself. How do we do that?*
You may have realized the motivation of this question, addressing itself withing itself
is exactly the nature of recursion. 

If we can define length abstractly, we can call it to simplify the reptitive procedure.
This need is particularly necessary when there is going to be many algorithms
having similar repetitions as =(length<=n)=.

First we deal with the first question, separating =(eternity)= by calling it
from argument, see in length<=0. Then we deal the second question, separating
length0 as "g calling eternity", addressing it through f.
#+begin_src scheme
;length<=0
((lambda (length)
   (lambda (l)
     (cond
       ((null? l) 0)
       (else (add1 (length (cdr l)))))))
 eternity)

;length<=1
((lambda (f)
   (lambda (l)
     (cond
       ((null? l) 0)
       (else (add1 (f (cdr l)))))))
 ((lambda (g)
    (lambda (l)
      (cond
        ((null? l) 0)
        (else (add1 (g (cdr l)))))))
  eternity))

;length<=2
((lambda (length)
  (lambda(l)
   (cond)
       ((null? l) 0)
       (else (add1 (length (cdr l)))))))
 ((lambda (length)
    (lambda (l)
      (cond
        ((null? l) 0)
        (else (add1 (length (cdr l)))))))
 ((lambda (length)
    (lambda (l)
      (cond
        ((null? l) 0)
        (else (add1 (length (cdr l)))))))
  eternity)))
#+end_src
The repetitions decrease but not pithy enough, and we can further simplify it.
Since we observe that the length testing part is highly similar, therefore we
call it =(mk-length)=, the length functions can be therefore written as:
#+begin_src scheme
;length<=0
((lambda (mk-length)
  (mk-length eternity))
 (lambda (length)
  (lambda(l)
   (cond
 ((null? l) 0)
  (else (add1 (length (cdr l))))))))

;length<=1
((lambda (mk-length)
 (mk-length
 (mk-length eternity)))
 (lambda (length)
  (lambda(l)
   (cond
 ((null? l) 0)
  (else (add1 (length (cdr l))))))))

;length<=2
((lambda (mk-length)
  (mk-length
   (mk-length
    (mk-length eternity))))
 (lambda (length)
  (lambda(l)
   (cond
 ((null? l) 0)
  (else (add1 (length (cdr l))))))))
#+end_src

In the length 0, the actual working part is =((null? l) 0)= and the =(else)= predicate
was never really got invoked. So in that predicate it doesn't really matter if we call =(eternity)=, or
even itself =(mk-length)=. Therefore we try further abstract it with this thoughts:
#+begin_src scheme
; length<=0
((lambda (mk-length)
   (mk-length mk-length))
 (lambda (length)
   (lambda (l)
     (cond
       ((null? l) 0)
       (else
         (add1 (length (cdr l))))))))

; since it doesn't really matter what to name the inner argument
; we rewrite length<=0
((lambda (mk-length)
   (mk-length mk-length))
 (lambda (mk-length)
   (lambda (l)
     (cond
       ((null? l) 0)
       (else
         (add1 (mk-length (cdr l))))))))

;use length<=0 to achieve length<=1 
(((lambda (mk-length)
   (mk-length mk-length))
 (lambda (mk-length)
   (lambda (l)
     (cond
       ((null? l) 0)
       (else
         (add1 ((mk-length eternity) (cdr l)))))))))
#+end_src
The last part in above shows: since the =(eternity)= is now substituted by the
=(mk-length)=, we can add one more workable layer on =(length0)=. This is achievable by calling the inner most
function =(mk-length)= with another argument of =(eternity)=.

The exercise in page 166 will help you on how it works. The instruction can be
found in the answer of =soegaard= :
[[https://stackoverflow.com/questions/10499514/y-combinator-discussion-in-the-little-schemer?noredirect=1&lq=1][scheme - Y combinator discussion in "The Little Schemer" - Stack Overflow]]

When running it with stepper in DrRacket, there are 27 steps for a case =(l is
(' a b c))=, I only demonstrate 4 steps here (press ctrl and + to see the enlarged image)

[[../static/img/little.png]]
You can try to play with longer list, such as this:
#+begin_src scheme
(((lambda (mk-length)
    (mk-length mk-length))
  (lambda (mk-length)
    (lambda (l)
      (cond
        ((null? l) 0 )
        (else (add1
               ((mk-length mk-length)
                (cdr l))))))))
 '(a b c))
#+end_src
You would realize that this is just more recurrences of that "bear in mind"
picture, aka calling =(mk-length mk-length)= one more time before applying a
shorter candidate list, until the =(cdr l)= runs out of atom. In the end, the null
list becomes the termination condition, without triggering it, we will go stack overflow by calling
=(mk-length mk-length)= infinitely.

After undertanding the above code, the author finanlly gets to reform this
procedure in to Y combinator, a function without defining name and so pithy that
can be called repetitively by itself as many times as we want.

If you find it confusing, read this preview of omega combinator in the first
answer of this post:[[https://stackoverflow.com/questions/10499514/y-combinator-discussion-in-the-little-schemer/11864862#11864862][scheme - Y combinator discussion in "The Little Schemer" -
Stack Overflow]]

** DONE Detailed key proof of ANOVA test: SST=SSE+SSB      :@MATH:statistics:
   CLOSED: [2020-03-09 Mon 00:07]
   :PROPERTIES:
:EXPORT_FILE_NAME: dd
:END:
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2020-03-09 Mon 00:07]
   :END:

*** Background
Note: the aim of this article is to provide a detailed proof of ANOVA foundation with full notation,
not to explain ANOVA. More explaintation can be found in the Youtube link.A

The ANOVA test is to use (rigorous mathmatical based) calculation to infer
whether there are differences in performance/data for different groups/treatment.
The ANOVA compares the within group variance (SSE:sum of squares within group) and between group variance (SSB: sum of squares between groups). The sum of SSE and SSB happens to equal
to the sum of deviation of all the individual observations (SST: total sum of
squares). Intuitively speaking with the SST unchanged, if the SSB is very big, the SSE tend to be very small. It's
very likely that these groups are from distinctively different worlds (or
population, or distribution) instead of the same world.

Here is an example, compare with the middle sample group, the other two sample
groups are more like from a different population:
[[/img/anova3.jpg]]
Source and detail can be found here: [[https://www.youtube.com/watch?v=0Vj2V2qRU10][Statistics 101: ANOVA, A Visual Introduction - YouTube]]

When I review the most foundamental knowledge of ANOVA test, I
notice two issues that make me feel necessary to write this detailed proof.
(1) The notation is not quite consistent across different materials,
especially for non-balanced dataset expression. Non-balanced datasets is that
every test group, or treatment has different numbers of observations. This is
almost everywhere in real world empirical studies.
(2)  Some of the prove of SST=SSE+SSB is missing steps or gets too complex in
polynomial expansions. The trick of proving multiple summation with polynomials
is "not to expand polynomials, but to use more distributive law".

*** Notation and Lemma 
So here I provide a note with full proof with consistent notations.
[[/img/anova1.jpg]]
*** SST = SSB + SSE
[[/img/anova2.jpg]]
** TODO Mathmatical similarity: measurements of distance in machine learning :@MATH:statistics: 
   :PROPERTIES:
   :EXPORT_FILE_NAME:
   :END:
 The core purpose of classification or causuality inference is differential
 diagnose, based the data we have. For example, in the behavioural
 classification, age, gender, nationality consist of a person's demographic file
 which can be seen as a point in a three dimentional plot. But how to draw a
 line that discriminately tells one person from its neighbour points requires lots
 of personal judgement. Sometimes, we want the numbers precisely represent the
 position of each point, but in more case, we choose special metrics or extra
 transformation in order to better discriminate the data. There are different type of way to mathmatically define
 these distances, but what makes a measurement great?

One of a common thought is that, two close points should be 

On the other hand, using one set of system for variables might not always be
ideal. For example, we want to use two 

** DONE Building personal website with Hugo in one hour :@TECH:
   CLOSED: [2020-04-13 Mon 22:57]
   :PROPERTIES:
:EXPORT_FILE_NAME: building-personal-website-with-hugo
:END:
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2020-04-13 Mon 22:57]
   :END:
This is a minimum todo list for one to use a static website generator to build a
personal website. The are a number of them such as Jekyll, Hexo, Octopress, World press,
Hugo, etc. I have tried all of the above and personally prefer Hugo for speed and
flexibility and compatibility with my Emacs. But another reason I recommend Hugo
to everyone is that: the Hugo community is really well-developed and supportive.
This is very important for non-proficient users to get help and not be baffled
by technicalities, so that we can get things done.  

If you are interested in building a personal wiki, academic profile, home
cooking recipe album, small business official website, building and managing a
website by these types of generator facilitates you with most flexibility with the
minimum cost. 

By most flexibility, I mean you can change the look of your website any time
with lots and lots of fantastic designs, and upload articles/photo whenever you want.
Check out the hundreds of themes Hugo:
[[https://themes.gohugo.io/][Complete List | Hugo Themes]]

By minimum expenditure, I mean zero cost, unless you want to get a customized
website name like /awesome.ai/ or rent some cloud based services to boost
visitors experience with your website.  

To do:
The process can be roughly showed in this pic:
[[/img/hugo.png]]

*** 1. Register a GitHub account and install local terminal.
[[https://product.hubspot.com/blog/git-and-github-tutorial-for-beginners][An Intro to Git and GitHub for Beginners (Tutorial)]]

Normally people use GitHub to share and maintain code repositories with
collaboration. But it can also host website repository for other people to visit. Using GitHub to
host personal website is free and encouraged. 

There are other options, such as purchasing personal server/VPS, using Gitlab or
other cloud based service. Each of them has its own advantage, but requires some more work or expenditure. 

Installing local terminal to push your local edited website content to remote
server. For example, if you are using Windows, install git bash from: [[https://gitforwindows.org/][Git for Windows]] 

/You don't have to learn all the git command unless you want to contribute to software/theme development. Building website do not refer those information. Only minimum
experience with command is sufficient./

*** 2. Download Hugo executable and installment. 
Everything you need to know is here, for all types of operating systems:
[[https://gohugo.io/getting-started/installing/][Install Hugo | Hugo]]

If you are a proficient command line user of Linux/macOS, =(homebrew)= it!

If you are a windows user and not sure which one to follow, the video in above
link should be sufficient. The download link he talks about is in *Less-technical Users* section. But make sure you update the environment variable. This
is where your git bash could find the Hugo binary and access to it.
[[https://docs.oracle.com/en/database/oracle/r-enterprise/1.5.1/oread/creating-and-modifying-environment-variables-on-windows.html#GUID-DD6F9982-60D5-48F6-8270-A27EC53807D0][Create and Modify Environment Variables on Windows]]

*** 3. Download and implement a Hugo theme.
You could take your time browse the Hugo theme shop and choose a theme according
to your needs. There are demos, which are real websites that people build with the
corresponding theme. Don't just look the front page, make sure you like the
structure, navigation style and everything since there are so many options!

You can change easily later if you want different things every now and then. 

Step by Step instructions to download and implement a theme:
[[https://www.youtube.com/watch?v=L34JL_3Jkyc][Installing & Using Themes | Hugo - Static Site Generator | Tutorial 5 - YouTube]]
Notice that he is using a macOS, if you are using Windows, the command line tool
he is using, is the Git bash in your environment.

If you are happy with the way domo site looks like, the easiest way is just to copy =(content, static,
config.toml)= from =themes/your-theme/(exampleSite)= and paste them with replacement to
home file. To rewrite the great theme template to your website, all you need to do is modifying
the template information in *config.toml* file.

Example of themes:
Casper [[https://brent-li.github.io/post/build-personal-site-with-hugo/][用Hugo搭建个人网站 · 李子峰的Github Page]]

LeaveIt https://mogeko.me/2018/018/

*** 4. Adding articles and local test
By the end of the third step, you should have a nice empty website in your name
with your photo. More you can do is adding articles. The article are all saved
in post folder, where you could initiate with:
#+begin_src 
cd myblog
hugo new post/name-of-new-article.md
#+end_src

You can always preview it in local host:
#+begin_src 
hugo server themename
#+end_src

Open web browser input =(http://localhost:1313)= to preview. Input =(ctrl-c)= in
Git bash to cease preview.

*** 5. Pushing work to remote server.
Make sure you generate html files into /public file first:
#+begin_src 
hugo -t themename
#+end_src

Push everything generate in /public file to =(XX.github.io)= repository. 
#+begin_src 
git init
git add .
git commit -m "Initial commit."
git remote add origin git@github.com:Brent-Li/brent-li.github.io.git
git push -u origin master
#+end_src


Unless you want to giving version control, not only for your website, but also for the
source code. Then you are gonna have to do some work because there are many ways
to achieve. I personally use two branches (dev for source code, and master for
/public) to manage because I prefer to keep codes intact with non-bloat management.

*** 6. More to do 
So far the minimum work that makes a sustainable website is done. Of course
there are more work to escalate the efficiency and fun. Such as:

(1). Get a personalized website domain (address) for people to remember.
This is one of the places where could use some money. GitHub has specific
requirement for using =(XX.github.io)= as name for website, which is hard to
remember, so you might want to check for buying a website domain with your own name:
[[https://www.namecheap.com/][Buy domain name - Cheap domain names from $1.37 - Namecheap]]
(There are many domain name sellers, all secondary distributors, so there are
slightly price different for a same domain.)  

At here you need to link the domain you bought to GitHub, so that when people
are visiting =(xx.com)=, GitHub will re-direct to =(xx.github.io)=.
[[https://www.namecheap.com/support/knowledgebase/article.aspx/9645/2208/how-do-i-link-my-domain-to-github-pages][How do I link my domain to GitHub Pages - Domains - Namecheap.com]]

Chinese instruction:
[[https://zhuanlan.zhihu.com/p/33261777][NameCheap域名解析教程 —— BasicDNS - 知乎]]

(2). Get Google Analytics to get statistics of the visitors of your website.
[[https://gohugo.io/templates/internal/][Internal Templates | Hugo]]
The process only needs adding two lines of codes. But this is a controversial demand because some people care about privacy or refuse
to create by traffic driven.

Chinese instruction:
[[https://note.qidong.name/2017/07/05/google-analytics-in-hugo/][Hugo中使用Google Analytics · 零壹軒·笔记]]

(3). Adding Disqus for visitor to comments

The website we generate is static website, which means generally the interactive
operations like searching/chatting/commenting is not supported. But there are
plug-in can help achieve.

(4). Adding site search with Algolia

(5). Auto deployment

(6). Search Engine Optimization

(7). Redevelopment of website theme

(8). Emacs users with ox-hugo
** TODO Why setting new keybinding sometimes is not replacing in Emacs
   :PROPERTIES:
   :EXPORT_FILE_NAME: why-setting-new-keybinding-sometimes-is-not-replacing-in-emacs
   :END:

Many people have been thinking about setting new keybindings when they find the traditional Emacs have many rather unconventional short cut keys.  

** TODO Emacs dotfile loading mechanism in Windows system
   :PROPERTIES:
   :EXPORT_FILE_NAME: emacs-dotfile-loading-mechanism-in-windows-system
   :END:

This post is about =(default directory)=.

As one may notice that calling Emacs from different places might not always be the same. The default dotfile in Windows nowadays is at =("c:/Users/YOU/AppData/Roaming/.spacemacs.d/")= Clicking runemacs.exe or calling from Command line Prompt, it can automatically load dotfile (e.g. theme, spacemacs). Whileas calling from Msys or Mingw git bash, it loads vanilla Emacs. Although when you run =(echo %HOMEPATH%)= in Powershell Prompt, or run =(echo $HOME)= in git bash, they all return the same HOME as =("c:/Users/YOU")=.

Why is git bash not recognizing the dotfile? (And powershell prompt knows to find dotfile not at HOME)

This is because Emacs for Windows has its own setting coping =(default-directory)=. When being called by git bash, Emacs inherits =(default-directory)= from git bash of =("c:/Users/YOU")=. But when being called from runemacs.exe and you didn't specify default-directory (by right-click icon - properties - start-in), Emacs didn't have place to inherit so it uses build-in default-directory, which is =("c:/Users/YOU/AppData/Roaming/")=. This can be verified by launching Emacs from different places and calling =(c-h v)=.

This is also the reason that calling Emacs from different places and launching =(c-x c-f)=, the directories are different. Of course, you can always reset the default working directory in dotfile as in answer from here: [[https://stackoverflow.com/questions/60464/changing-the-default-folder-in-emacs][customization - Changing the default folder in Emacs - Stack Overflow]]

