   #+hugo_base_dir: d:/Google drive local/Hugo/myblog/
   #+hugo_section: post  
   #+hugo_auto_set_lastmod: t
   #+hugo_code_fence: nil  
   #+hugo_front_matter_key_replace: description>summary
   
* Blog
** DONE Hugo blogging with Ox-hugo 【用 ox-hugo 在 Emacs 中搭建网站流】 :@TECH:Hugo:Ox_hugo:
   :PROPERTIES:
   :EXPORT_FILE_NAME: Hugo blogging with Ox-hugo
   :END:
   :LOGBOOK:
   - State "DONE"       from "DONE"       [2019-07-24 Wed 00:42]
   :END:

#+begin_description 
My personal experience of blogging with Emacs/Spacemacs and plug-in ox-hugo, along with some explaination of Hugo's working structure.
#+end_description

There have been many good articles talking about using ~ox-hugo~ to aid
efficient blog writing in Emacs/Spacemacs. I read these articles carefully
several times and feel pretty confident using ox-hugo, so I would strongly
recommend you give them a look:

[[/img/Hugo blogging with Ox-hugo 8.png]]
This is true for many cases, but no, not for Hugo or ~ox-hugo~. They are amazing official documentation! (Mr.Kaushal I know you occasionally search ~ox-hugo~ related articles in all different languages. If you happen to read this, thank you!)

• [[https://ox-hugo.scripter.co/][ox-hugo official documentation]] is very well written. The author carefully demonstrates not only all basics of using ~ox-hugo~, but also some killer choices to improvise. 

• [[https://gtpedrosa.github.io/blog/using-org-mode-and-ox-hugo-to-replace-markdown-in-hugo-workflow][USING ORG MODE AND OX-HUGO TO REPLACE MARKDOWN IN HUGO WORKFLOW]] and the three other articles mentioned are very helpful to me too.

• [[https://www.kengrimes.com/ox-hugo-tutorial/][Ken's ox-hugo tutorial]] is the source of some of my sections mentioned below, which you can see the snapshots are directly from Ken's blog. I re-edit it to help understand the logic of the section tree. 
 
Most content comes from the Hugo official documentation along with these articles. I noticed that there had been quite a few Chinese articles talking about Hugo and ~ox-hugo~, so I am writing this in Chinese.

我放弃 Hexo，安装 Hugo 的最初目的还是想用它配合 Emacs-org-mode 来写博客记笔记。灵感来自[[https://zilongshanren.com/post/move-from-hexo-to-hugo/][子龙山人]]和[[https://www.xianmin.org/post/ox-hugo/][贤民]]两位老师的博客，具体的安装和使用心得二位已经介绍的非常详细，仔细读完会受益良多。本着不再重复造轮子的原则，这篇文章我想简单写写学习中遇到到有用的东西：Hugo 原生的结构设计；Hugo 与 ~ox-hugo~ 的对接原理；在 Emacs/Spacemacs 使用 ox-hugo 帮助我们在 org-mode 以极高的效率写博客并发表。

在阅读本文之前，强烈推荐阅读开头推荐的三部分内容。本篇博客主要就是整理了加工了一些来自 Hugo 官网，和以上三篇文章的内容，并配以更直观的图片帮助理解。对我来说 ox-hugo+org-mode 最牛的地方的在于高度集成。org-mode 有一个优秀的原生功能是通 tags 等功能，用一个大文件+一二三四五级小标题就能管理一个文本文件树。具体到本文就是，通过一个文件管理整个网站的内容撰写。这是作者力荐的写作方式，也是他编写这个插件的主要初衷。比起各种单个文件组成的零散网站管理模式，这个结构更清晰，管理更容易，搜索 toggle 都十分方便。作者用 ~ox-hugo~ 的官网直接展示了样版：
[[https://ox-hugo.scripter.co/doc/why-ox-hugo/][Why ox-hugo? — ox-hugo - Org to Hugo exporter - https://ox-hugo.scripter.co/]]

这样的结构配合上一些 Emacs 自带的 killer 功能例如 ~writeroom-mode~,
~org-tree-to-indent-buffer~ , ~predictive~ 英文补全, ~org-capture~ 一键捕获，能瞬
间让写作如虎添翼。

*** 0. Org markup syntax and killer reference card
在写了 7 篇文章以后，其实我还是 org-mode 语法记忆困难户。官网给了零星几个常见的语法
参考，但是 org-mode 能定制格式花样的远不止于此。我在此给出一个终极解决方式：参考网站原文的
org file。网站 org 源码从 org markup 形式到 hugo section 的 front information 都有涵盖，在网站
看到想要的格式去原文直接搜索照搬即可：
[[https://ox-hugo.scripter.co/doc/hugo-section/][Full website]]
[[https://raw.githubusercontent.com/kaushalmodi/ox-hugo/master/doc/ox-hugo-manual.org][Full website source file]]

*** 1. Front matter 页首信息
Hugo 本身其实支持直接把.org 文件渲染成 html 发布，但是许多人提到其实支持得不是很好。Hugo 支持最好的 markdown 语法类型是 blackfriday markdown。对很多 Emacs user 来说 org-mode 就像把有力的大锤，碰上跟写作沾边的任务不能抡一下是很遗憾的。所以可以使用这款非常棒的后端插件 ~ox-hugo~ 来支持 org-mode 写博文。它的解决方式是：把 org 文件转成 blackfriday markdown, 然后再生成 html 文件。首先我们详细看 ~ox-hugo~ 官网对其功能的解说：

#+begin_quote
According to the information documentation, ~ox-hugo~ is an Org exporter backend that exports Org to Hugo-compatible Markdown (Blackfriday) and also generates the front matter (in TOML or YAML format).
#+end_quote 

	
简言之，我们主要使用 ~ox-hugo~ 做两件事（1）把 org 格式内容转换成 markdown 格式内容；（2）解析 org file 中的用 org 语法写 front-matter，生成 Hugo 要求语法的 front-matter，使得 Hugo 通过正确的信息生成的 html 。那么 front-matter 具体指什么呢？



Front matter give the information about the content, but NOT the information of content. It works as metadata to tell Hugo the general properties of the article. Hugo supports three types of front matter syntax: yaml, toml, json. Wheven you generate a new post/article/blog with
#+begin_src 
$ hugo new site posts 
#+end_src
Hugo will automatically add front matter information at the top of the article like this:
#+begin_src 
	---
	title: Good day
	date: 2017-09-01T1705-43                    (YAML)
	draft: true
	---
	
	+++
	title= Good day
	date= 2017-09-01T1705-43                   (TOML)
	draft= true
	+++
	
	{ 
	"title":  "Good day" ,
	"date": "2017-09-01T1705-43",           (json)
	"draft": "true"
    }
#+end_src
	
所以想用 org 进行 blog 写作，也需要定义自己的 front matter. 但是 org file 里 front matter 语法如下
#+begin_src lisp
:PROPERTIES:
:EXPORT_FILE_NAME: ox-hugo-tutorial
:EXPORT_DESCRIPTION: Exporting to Hugo's Blackfriday Markdown from Orgmode
:EXPORT_HUGO_IMAGES: /img/org.pn
:END:
#+end_src

以 ~:properties:~ 这块为代表的代码就是 org 以自己的方式定义 meta
information。~ox-hugo~ 会解析改写这个这些代码以生成 hugo 可以识别的 YAML 等 front matter.
	
Ox-hugo 一般要求至少要有 ~:EXPORT_FILE_NAME:~ 。我们需要通过这个命令告诉
ox-hugo"有新的标题和内容需要去导出"。

*** 2. Don't get confused 易混淆的概念
接下来这个问题可能对多大多数前端 coder 和 Emacs 熟练手都不是问题，但是这两个段头部代码被我着实混淆了一阵：
	
通用 Front matter 主管面向一个 article 内部的性质设置，例如写作作者，写作日期，写作 tag。Heading information 例如 ~#+hugo_base_dir~ 的概念局限于 ~ox-hugo~ 里，是遵从
org-mode 特色的命名方式设计的变量，类似的语法在其他 org 文章的管理信息中也可以
看到。而 front-matter 这些变量
在 markdown，网页 config file 等其它文件里都有。只是 ~:PROPERTIES:~ 这种表达形式
是 ox-hugo 特色写法。换做 org 支持的另一种 projectile 导出 html 的 front matter 可能是这样:base-directory "~/Dropbox/org/blog/".


*** 3. Content type
	Content type 就是一系列不同的表达式样（layout），根据我们指定的不同的 section type 有不同表达式样法则，这里暂且把 section 翻译成一个网站下的不同栏目，例如 blog，photo，quote，post，about，tages 或者其它你想自定义的栏目。Hugo 通过 front-matter 支持这些不尽相同的 content type。
	
	Hugo 认为每个栏目最好只做同一件事情，例如照片专栏只发发照片，post 专栏集中发文章。所以除非我们自定义，hugo 指定每个栏目的子单元都会自动继承一些此专栏 pre-defined 的特性，这样能最大限度的重复使用一个定义好的栏目，同时尽量减小‘config 每个栏目’工作。
	
	设定 content type: 只需在源文件的头部引用 hugo 提供的 heading
	information/metadata information（即 front matter）即可，能迅速方便的修改一
	两个页面的 layout。如果不能满足需求，可用 hugo 提供的自定义设置 archetypes，
	按照 hugo 指定的结构组合方式，编写正确的_index.md 文件拼接好一个网站的
	layout 即可。 
	
	如果你没有指定表达式样，比如暂时不太在乎如何展示 photo 这个栏目，Hugo 有这么一个 default 设定：在 front matter 大部分信息缺乏的时候，通过每个文章存储 path 或者所在 section 猜出给这篇文章赋予什么 layout。这会让我们在迅速上手写作 blog 的时候非常省心。
*** 4. Page boundles
	Hugo 0.32 以上的版本，使用 page boundles 的模式来管理网页源和图，从父子结构分类的角度看，有两种：leaf 类页面和 branch 类页面。branch 类页面允许在其内部嵌套更深层次的页面，而 leaf 规定其不能再有子页面。
	
	任何一个叫 index 的页面文件都是 leaf 型，叫_index 的页面文件都是 branch 型。所以可见 org 文件里 index 的文件都会被输出成单页，没有子文件夹。最常见的 index 页面是下文会提到的分类里面的 categories 和 tags index pages，它们都是单页，除此之外多数时候我们会使用 branch 型。如图:
[[/img/Hugo blogging with Ox-hugo 1.png
]]
	Content 文件夹在这里是 home page, 他的主要功能是 hosting“决定网站 layout 设定”的信息（在这里就是定义了 branch 型页面类型的_index.md），所以 hugo 规定 home page 至多只能包含图片，而不能包含其它的 content pages，只承担 layout 设定而不为 article source 提供场所。注意 content 里面的内容结构安排，应当和你想要渲染的网站结构一致。

*** 5. Section and nested section
	Section 是一组页面的集合称呼，一般被放在 content 文件夹下面，就是上文提到的‘内容结构组织’的组成单元。从 default 设定来讲，content 下面的每个一级文件夹自成一个 root section。同时上面也提到 section 可以嵌套，即在一级文件夹下方再建二级 section 文件，构成一个更深层的 section。
	
	那么问题来了，hugo 是如何知道 nested section 呢? 答案是：通过文件夹里要有_index.md 文件指定结构的设定。依此原理可以构建三级四级更深的 section 目录。 为了确保每一级网页都能被导览正确的链接到，每个最底层的文件夹里都要至少包含一个有内容文件，例如_index.md.
#+begin_src 
content
└── blog        <-- Section, because first-level dir under content/
    ├── funny-cats
    │   ├── mypost.md
    │   └── kittens         <-- Section, because contains _index.md
    │       └── _index.md
    └── tech                <-- Section, because contains _index.md
        └── _index.md
#+end_src

*** 6. Head information
~ox-hugo~ 对 org 文件存放位置并没有特定要求，但是其头部的 ~#+hugo_base_dir:~ 必
须要被清晰的定义，因为这个地址告诉 ~ox-hugo~ 你的 root directory 在哪里，
~ox-hugo~ 就会在这个地址下的 content 里面生成转化的 md 文件。很多用户自定义
~#+hugo_base_dir:~ ..即是本 org 文件所在的 parent path.也有人定义
~#+hugo_base_dir:~ .代表 path 与现在的 org 文件同文件夹，如果 root directory 是
跟现在 org 文件同文件夹，c-c c-e H A 导出 markdown 文件的结果就是这样：
[[/img/Hugo blogging with Ox-hugo 2.png]]

	仔细体会以下示例：以 root 目录 c:\hugo\myblog\为例：
	(1) orgfile 在 myblog 下方 且#+hugo_base_dir: .
	(2) orgfile 在 myblog\content-org 下方 且#+hugo_base_dir: ..
	在 c-c c-c H A 后都会产生如下形式，只不过(2)中 hugotest.org 在 content-org 里面
[[/img/Hugo blogging with Ox-hugo 3.png]]

*** 7. Heading management
The official documentation as well as the attached youtube tutorials have provided great explaintation of how hugo translate metadata of _index.md files to the headings of html with Hugo heading management system.
	
建立一个有一篇文章的 post
[[/img/Hugo blogging with Ox-hugo 4.png]]

继续新增一个有两篇文章的 fishsticks
[[/img/Hugo blogging with Ox-hugo 5.png]]

*** 8. Tree and subtree writing
	In normal Hugo, individual pages written in markdown (or now in org-mode)
	are placed inside the content directory inside the project root. With ~ox-hugo~, a single org-mode file can be used to generate all pages, posts, and any other content. This has some advantages in allowing usage of org-mode functionality, as well as re-use of content or property settings across pages.

[[/img/Hugo blogging with Ox-hugo 6.png]]

*** 9. Taxonomies 分类型页面
这段是 index 管理 page boundle 的良好功能的又一个展现:通过 taxonomy index pages 就能建立一系列分类页面,例如 tags and category,为分类页面单独建立管理 page 使拥有这些属性的文章被自右交叉引用,用户可以通过点击任何一个 tag 或者 categories 就能达到文章页面。在 org 写作里通过在 headings 添加实现，org 到 md 转化由 ~ox-hugo~ 完成，语法差别很细微。如下图，还是上文的源码，只是为文章添加了两种 categories，两种 tag:
[[/img/Hugo blogging with Ox-hugo 7.png]]

在源码的三篇文章里分类 update 和 reviews 被提到两次，标签 fear 和 herpes 也被提到两次。从生成的 html 来看，
index.md 刚好与之对应：分类的 index page 提供了所有需要的分类（i.e. tags, categories）每个分类下还有 list page 显示所有与之相关的页面内容。导航就是这样实现建立的，使得我们能“实现不同分类间的交叉引用，点击任何一个入口进入文章”。

** DONE Hugo Blogging with Wercker Auto Build & Deployment 【用 Wercker 自动部署网站】 :@TECH:Hugo:Git:Wercker:Org_mode:Emacs:
   CLOSED: [2019-07-26 Fri 01:02]
   :PROPERTIES:
   :EXPORT_FILE_NAME: Hugo Blogging with Wercker Auto Build & Deployment
   :END:

#+begin_description
Using Wercker to for automated website code build and deployment
#+end_description

The automated static website generators (e.g. Octopress, Hexo and Hugo) have made *website buiding and maintaining* way more relaxed than before. The workflow has been simplified to: write and save markdown -- preview on the localhost 1313 -- generate the ~/public (HTML) file -- push to a remote server (Github) -- backup source code. 

If one considers all technicalities, there are still many questions worth discussing to make this process more efficient, such as (1) which is the best way to host HTML files and source code files (2) which is the better way to automize the procedure.

I used to use Hexo where three things need to be tracked separately:  source code and ~/public file (both updated for every article), forked/cloned theme (updated according to theme author) and Hexo generator. I have to use git submodules to track everything. Soon, the hustle and page generation speed make me convert to Hugo. Hugo requires only a binary file to generate a website, with which the update cannot be more straightforward: you download a new .exe file and replace the old one. The updated theme can be manually merged as long as the site config.toml file is well preserved. 

Let's go back to the first issue. The Hugo official manual has given two way to publish ~/public file: (1) using Master branch of user.github.io to host /doc (instead of public) folder, which is the easiest one to me; (2) using gh-pages and the advantage of this method is that allows you to have another branch hosting source code in the same repo. I fail to generate /doc file somehow, but it gives me a chance to try Wercker, which surprisingly allows me to achieve the first method with the same advantages of the second method. Long story short, now I am using the Master branch of user.github.io to host ~/public file and dev branch to host source file.

My answer to the second issue is using Wercker. It will automatically go to your source code repo and build the ~/public folder and deploy the website. So the process mentioned at the beginning of this article becomes even easier: write and save an article in markdown -- push the whole source code to the remote repo. This means you do NOT need to generate and deploy in the local terminal any more. Wercker does the work every time it detects a new push on the designated repo on the remote server. The script  wercker.yml (generated and pushed by you) will tell Wercker precisely how and where to build and deploy. There're also other popular continuous integration tools such as Travis CI, Jenkins which has advantages at different aspects such as free usage, commercial stability, running speed and etc. I choose to use wercker based on my needs.

The Hugo instruction [[https://gohugo.io/hosting-and-deployment/deployment-with-wercker/]] is very detailed and well written, and you should be quite clear before the 'Configure Access' section. The Wercker has changed quite a bit in the generating wercker.yml part. You do NOT HAVE to search and choose boxes or steps to build and deploy. The default script contains the box information, and it can be modified unless you don't like it. The build and deploy part are generated separately in the workflow section (press ctrl and + to see the bigger picture) [[D:/Hugo/myblog/static/img/Hugo blogging with werecker 1.png]] 

Here is my wercker.yml:

#+begin_src yml
# This references a standard debian container from the
# Docker Hub https://registry.hub.docker.com/_/debian/
# Read more about containers on our dev center
# https://devcenter.wercker.com/overview-and-core-concepts/containers/
box: debian
# You can also use services such as databases. Read more on our dev center:
# https://devcenter.wercker.com/administration/services/
# services:
    # - postgres
    # https://devcenter.wercker.com/administration/services/examples/postgresql/

    # - mongo
    # https://devcenter.wercker.com/administration/services/examples/mongodb/

# This is the build pipeline. Pipelines are the core of wercker
# Read more about pipelines on our dev center
# https://devcenter.wercker.com/development/pipelines/
build:
    steps:
    # Steps make up the actions in your pipeline
    # Read more about steps on our dev center:
    # https://devcenter.wercker.com/development/steps/
        - arjen/hugo-build@2.8.0:
            # your hugo theme name
            theme: hugo-theme-cleanwhite
            flags: --buildDrafts=false
deploy:
    steps:
        - install-packages:
            packages: git ssh-client

        - sf-zhou/gh-pages@0.2.6:
            token: $GIT_TOKEN
            domain: sheishe.xyz
            repo: QiKatherine/QiKatherine.github.io
            branch: master
            basedir: public
#+end_src

Notice the name 'build' and 'deploy' in the workflow above need to be the same with the name in steps in the wercker.yml file.

You can also add a local deploy.sh to make source code push easier too:

#+begin_src bash
  #!/bin/bash
  cd ~/Hugo/myblog/

  # Add changes to git.
  git add .

  # Commit changes.
  msg="rebuilding site `date`"
  if [ $# -eq 1 ]
    then msg="$1"
  fi
  git commit -m "$msg"

  # Push source and build repos.
  git push origin -u dev

#+end_src

Happy hacking! :)


** DONE Best workaround to use Emacs in MS Windows 【在 MS windows 中使用 Emacs 的最佳解决方案】 :@TECH:Emasc:Msys2:Windows10: 
   CLOSED: [2019-08-16 Fri 01:03]
   :PROPERTIES:
   :EXPORT_FILE_NAME: Best workaround to use Emacs in MS Windows
   :DESCRIPTION: Compiling Emacs with msys2 environment.
   :END:
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2019-08-16 Fri 01:03]
   :END:

#+begin_description
Experience Emacs with best workaround enviroment in windows.
#+end_description

*** Background 
Due to the working environment limitation, I occasionally have to use MS windows system (and therefore Emacs for Windows). But some similar users and I have constantly found cases where Emacs is significantly relying on *unix system. So far, my experience is that compling Emacs in msys2 has been a best (maybe) workaround in this situation. If you this is relatable to you, you might want to give it a try:
https://chriszheng.science/2015/01/23/Guideline-for-building-GNU-Emacs-with-MSYS2-MinGW-w64/
There has been ample discussion online, so I will be writting in Chinese. If you are interested in the trouble shootings below, try google translate. It will be fun :).


我因为工作的原因有时候不得不使用 Windows。Emacs for Windows，在这种情况下，已经是一个比较合适的选择了，我用了半年多对它各方面都还相对满意。但是总不时会发现，Emacs 里面还有很多严重依赖*Unix system 的操作。为了找到一劳永逸的办法（做梦），我尝试过 cygwin, mingw64 还做了一些功课，目前发现最好方式是，将整合到 msys2 里面使用，或者使用 msys2 编译的 Emacs。

*** MSYS2
MSYS2 是 MS-Windows 下编译自由/开源软件的一个环境，衍生自 Cygwin，也就是说它和 Cygwin 一样，编译出的程序不能脱离 Cygwin 环境运行(其实就是离不开那几个 DLL 文件)。但 MSYS2 有一个很牛的地方是它自带了 MinGW-w64，MinGW-w64 可以认为是 MinGW 的升级版本，编译出的程序是原生的 Windows 程序，最大的特点和名字一样，支持编译出 64 位的程序。目前 MSYS2 和 MinGW-w64 开发都很活跃，两者结合，既发挥了 MSYS2 对*NIX 世界的兼容性，又能用 MinGW-w64 编译原生代码，很爽，自带的包很丰富，包管理采用 Arch Linux 用的 Pacman，非常的方便。

据说 msys2 目前是提供最多类 Unix 开发工具的环境，而且为想尝试*unix 的 windows users 整体上提供了十分优秀的模拟环境。

Msys2 的下载安装都很简单，参照管网指南操作即可。中文用户配置可以参考以下链接：
https://zhuanlan.zhihu.com/p/33751738
https://zhuanlan.zhihu.com/p/33789023

*** Compiling Emacs
/在 msys2 里面安装最简单的是使用 pacman -S Emacs，安装完的版本在 c:/msys2/usr/bin 里，dotfile 在 c:/msys2/home/user/.emacs.d 下方，我试图运行内置 function，正常，但是使用 dotfile 加载同样的 function 总显示加载错误。/ 

而且 chris 老师提到 Windows 下使用 emacs 最好的方式还是用自己编译的 Emacs，所以我也选择这么做。自编译 Emacs 要安装一系列 libraries，然后从原代码 git.sv.gnu.org/emacs.git 从这里 clone 所有的东西下来，按下列文章一步一步编译
https://emacs-china.org/t/topic/3276/13
https://chriszheng.science/2015/03/19/Chinese-version-of-Emacs-building-guideline/
http://git.savannah.gnu.org/cgit/emacs.git/tree/nt/INSTALL.W64

这个安装包都是为了在 msys2 中编译 Emacs 而写，所以安装途中不需要由什么特别改动的地方，注意一步一步执行代码就好。还有一点不得不提，Gti 自动改换行符的功能(autocrlf)很讨厌，会造成各种意想不到的神仙 bug（e.g. 很多人猜测这个也是造成 spacemacs 版本的 font-lock+ error 的原因）我们用下面的命令关掉它：
$ git config core.autocrlf false
=Update: 新版的git已经默认这项是关闭了。如果有需要，可以安装完后再把值改回true，一直默认关闭会导致有些git操作持续return warning，泪目。=

安装时需要一些依赖库，如果你的系统里面 MSYS2 已经被添加到 PATH 环境变量里(例如 PATH 里包含了 C:\msys2\mingw64\bin)，就不用从 mingwin64/bin 里面复制必用的 libraries 去 c:/emacs1/bin 了，所以直接在 PATH 里添加环境会比较方便。

*** Advantages
跟以前使用的 Emacs for MS Win64 一样，emacs 配置文件还是默认在 C:/Users/AppData/Roaming/.emacs.d 中。大多数 package 放在本地 c:/msys2/home/user/.emacs.d/elpa/yourdir/以后使用 ~(add-to-list 'exec-path "yourdir")~ 即可正常调用。

但是我感觉从运行速度来讲，msys2 compiled Emacs 比 Emacs for Win64 =快很多= 。所以在 win 中使用 Emacs，虽然也有 WSL 或者 VM based 的解决
方案，但是 msys2（在许多人看来）仍然是一个在 win 环境中使用类 unix 系统的优秀途径，希望未来能研究编译过的 emacs 在 msys2 提供的类 unix 系统里是否和其他 libraries 有更好的互动。

** DONE Org-reveal: solution for math and code highlighting in presentation slide 【在 ppt 中展示代码高亮，数学公式的优秀解决方案】 :@TECH:Emacs:Org_mode:
   CLOSED: [2019-08-23 Fri 22:50]
   :PROPERTIES:
   :EXPORT_FILE_NAME: org-reveal-solution-for-math-and-code-highlighting-in-presentation-slide
   :END:
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2019-08-23 Fri 22:50]
   - State "TODO"       from "DONE"       [2019-08-22 Thu 00:54]
   - State "DONE"       from "TODO"       [2019-08-22 Thu 00:44]
   :END:
 
#+begin_description
Learning notes and trouble shooting for using org-reveal.
#+end_description

I have used flash card for remembering new things for years. Before using software like org-drill or Anki, I was pretty much putting everything in slides, printing on papers and cutting it into a portable sized card and carried in my pocket. So I have been exploring an ultimate solution of perfect formatting for everything. This picture shows what I feel about slides making tools.
[[../static/img/org-reveal.jpg]]

I always thought math functions display tricky, but the Latex with Beamer has provided an adequately good template for most people. As a comparison, the code highlighting is tricker, especially for not-so-prevalent programming languages like Lisp. In order to adequately demonstrate code highlighting, sometimes people have to paster code in Notepad++ with designated formatting, then paste into MS word, then to MS powerpoint. Or take an alternative hustle to explore various online highlighting transformation tool. If you are looking for a long term hustles solution, then I think "Emacs/Spacemacs + Org-mode + org-reveal" makes an excellent tool for you.
• [[https://github.com/yjwen/org-reveal/][yjwen/org-reveal: Exports Org-mode contents to Reveal.js HTML presentation. - https://github.com/]]
• [[https://opensource.com/article/18/2/how-create-slides-emacs-org-mode-and-revealjs][How to create slides with Emacs Org mode and Reveal.js | Opensource.com]]
• [[https://revealjs.com/?transition=fade#/][reveal.js – The HTML Presentation Framework - https://revealjs.com/]]

The above links give many details of the code/manual/demo of org-reveal.Specifically, the second and third links provide excellent instruction about how to toggle and customize your presentation. I highly recommend you to give them a look.

In this article, I am only adding a few trouble shootings for the issue that I met.

The installation did three things (1)installing ox-reveal (2)installing reveal.js (3)installing htmlize, but the spacemacs comes with htmlize installed.

I add ox-reveal in the package list of spacemacs dotfile, reloading the dotfile but it did not installed. The author also mentioned that ox-reveal in MELPA maybe out of date. So alternatively, I downloaded the .el file and manually required it.

There are also two ways of calling reveal.js as described by the readme. I am using the second where the source url was put in the config file. Notice there seems to be an old url(http://cdn.jsdelivr.net/reveal.js/3.0.0/) which does NOT work any more. If your exported html file is just an empty page with theme background, check if you are refering to the right url. The current source and config code is shown below:


#+begin_src emacs-lisp
;; Emacs
(require 'ox-reveal)
(setq Org-Reveal-root "file:///path-to-reveal.js")
(setq Org-Reveal-title-slide nil)


;; Spacemacs/Using use-package
(defun yourname/post-init-ox-reveal ()
  (use-package ox-reveal
    :ensure t
  (setq org-enable-github-support t)
  (setq org-enable-reveal-js-support t)
  (setq org-reveal-root "https://cdn.jsdelivr.net/npm/reveal.js")))
#+end_src

** DONE Mastering emacs in 21 days learning notes - 1 【21 天学会 Emacs 笔记 - 1】 :@TECH:Emacs:
   CLOSED: [2019-08-25 Sun 23:51]
   :PROPERTIES:
   :EXPORT_FILE_NAME: mastering-emacs-in-21-days-learning-notes-day-1-21-天学会 emacs 笔记-第一天
   :END:
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2019-08-25 Sun 23:51]
   :END:
 
This article is part of my learning notes of Mastering Emacs in 21 Day, which is a series of Chinese based tutorials post by [[https://github.com/zilongshanren][zilongshanren (子龙山人) - https://github.com/]] The official learning note is at here: [[http://book.emacs-china.org/][Master Emacs in 21 Days - http://book.emacs-china.org/]]  My notes extend the official notes with my personal learning experience. Since there has been ample discussion of using and learning Emacs in English community, my learning note is written in Chinese to benefit more addtional readers. 

这篇文章是我学习子龙山人老师的 spacemacs rock 系列笔记之一。在原视频配套的基础上
我还做了一些扩展和补充，有的知识点还加了视频对应【集数-分钟】的时间点，以便迅速
观看视频.

*** 1. 基本知识 
-----
• Emacs 相当于一个 elisp based 的操作系统。这个操作系统的原理是，每次 Emacs 启动
过程就相当于一系列功能通过 loading files(代码块)的实现。在每次使用前，成百上千的
functions 被加载到 workspace 中(其中一些带着 default 参数) ，等待被调用，或者被
custermize。因此所有的设置，架构都可以通过调 function portal 修改成想要的 value；
或者在原有的 value/function 的基础上，继续开发一系列指令来增进，比如我们自己编写
的各种自定义函数。连整个 emacs 的启动都可以概括为一句话：加载一系列脚本。只不过
这些脚本有的是内置的（built in），有的来自安装的插件包，有的是我们自己写的。配置
emacs 归根结底是在配置各种各样的脚本。

• 首次加载一个配置复杂/成熟的 Emacs（例如 spacemacs 或 Purcell 的 Emacs），会耗
费比较长的时间，因为需要依次安装所有 cofig.el 中提到过的 packages。在经过首次配
置之后的时间里，每次启动 Emacs 的 loading file 主要以加载和更新为主，而极少数
package 安装只有才加载检查发现没有 package 时候才会发生。

• loading 的文件主要是.elc 文件，是经过编译的.el 文件的二进制形式，加载更快。但平日的修改是在更容易阅读的.el 文件上进行的，所以如果你手动修改完.el 文件，一定要记得编译以便 Emacs 自动执行，For example with Emacs-Lisp you do:

#+begin_src emacs-lisp 
 (byte-compile-file "foo.el")
#+end_src
否则 Emacs 要么加载没有被同步修改的二进制.elc 文件，要么会因为没找到.elc，去加载更缓慢的.el 文件。
	
• 光标放在最后一个反括号的末尾，按 C-x C-e，是执行一行命令 on the fly，作用等同于 M-x 命令 回车。

*** 2. 新建 init.el【26’50】
-----
• 初始 hacking：
Emacs 像一个状态机，即使还没 config init.el, 裸机 Emacs 也加载了许多 build-in
functions 以确保能被基本使用。所有的状态在 default value 下运行。在这种情况下，
可以通过 M-x 调用已有的命令来做到修改设置，但是所有临时设置的东西关掉后都会被删
除，还原成默认值，被称为 =临时改动= 。还有一种就是直接去 el/.elc 的脚本里修改代
码 hard coding modify，有很多坏处。比如，每次更新插件，都要自己回去重新修改，被
称为 =永久改动= 。
	
• 初始化设置：
所以更好的选择是不动原脚本，通过预加载修改达到目的，也就是手动写一份 init.el 的意义。为了使得 emacs 每次打开都有最佳设置，我们在 C:\Users\AppData\Roaming\.emacs.d\文件下新建了 init.el 的 elisp 文件，来写想要的配置。因为 Emacs 默认设置打开时，会自动寻找 home 目录的.emacs.d\文件下下面 init.el 文件来执行：（1）如果找得到，每次开启 Emacs 都先重新执行一遍我们的 config，以达到预加载我想要的全部舒适配置；（2）如果其不存在 init.el，Emacs 还是原始裸机也能用；（3）如果 init.el 代码有错没加载成，也是裸机（后面使用 usepackage 来管理初始加载，可以避免这种“因为一点小错误”使得整个初始加载都失败”的问题）。
	=注意：** 如果希望把配置放在 ~/.emacs.d/init.el 文件中，那么需要手工删除 ~/.emacs 文件。=
	
• 使用 init.el 管理 personalized config 额外的好处是，init.el 文件还可以在
GitHub 备份，在初始化文件里加上一个系统类型判断函数，让我们在任何地方的的不同主流
系统都可以自由使用。甚至，不用修改别人电脑里有的 Emacs 配置，用 U 盘就能在一个 Emacs 里使用不同的 config。
	
	
• Emacs 的命令执行是按顺序来的，这个顺序既只文件也只内部命令。各种 function 一个
一个的被调用 （也就是 load/require），一行完成后再进行下一行。例如，只保存第 1 个命令，下次打开 Emacs 显示字体为 16pt；保存 1.2 命令，在 1 之上 load open-init-file 命令去 workspace；保存 1.2.3 命令，在 12 之上还能使得我们通过按 f2 真正调用这个 open-init-file:

#+begin_src emacs-lisp
;; 更改显示字体大小 16pt                                 
(set-face-attribute 'default nil :height 160)                   ---- 1

;; 快速打开配置文件
(defun open-init-file()
  (interactive)
  (find-file "~/.emacs.d/init.el"))                             ---- 2

;; 这一行代码，将函数 open-init-file 绑定到 <f2> 键上
(global-set-key (kbd "<f2>") 'open-init-file)                   ---- 3
#+end_src
这个知识点目前看起来很简单，但是以后涉及到要去其它.el 文件层层加载，记得这个顺序性 load 的特质会帮助理解 Emacs 的加载机制。
	
•在 Emacs 里命令按行顺序执行 A--C，如果遇到“call A 的前提是先要加载 B function”（但是 B 没有加载在 workspace 里的情况时），Emacs 会先走开，去 B.el 相关的文件 load B function，执行完再回来继续加载剩余的东西，然后再执行 C。因此相互依赖的 feature 有可能因为调用顺序没安排好而导致 initiliaze 出错，这样能解决。为了解决依赖顺序造成的潜在问题，Purcell 写了一个 after-load 函数，目的是把一些相互依赖的 feature 的加载顺序理顺，例如 feature A 依赖于 feature B，则可以写成(after-load 'B 'A)，这样如果错误地在 B 之前 require 了 A 也不会影响正常启动：

#+begin_src emacs-lisp
(defmacro after-load (feature &rest body)
  "After FEATURE is loaded, evaluate BODY."
  (declare (indent defun))
  `(eval-after-load ,feature
     '(progn ,@body)))
#+end_src


*** 3. Major mode and minor mode
-----

• 在开始配置之前让我们先来区别 Emacs 中 major mode 与 minor mode 的区别。Major mode 通常是定义对于一种文件类型编辑的核心规则，例如语法高亮、缩进、快捷键绑定等。 而 minor mode 是除去 major mode 所提供的核心功能以外的额外编辑功能（辅助功能）。 例如在下面的配置文件中 /tool-bar-mode/ 与 /linum-mode/ 等均为 minor mode。

【查看 minor mode】简单来说就是，一种文件类型同时只能存在一种 major mode 但是它可以同时激活一种或多种 minor mode。鼠标放在 powerline 可以显示一些 minor mode 信息，如果你希望知道当前的模式全部信息，可以使用 =C-h m= 来显示当前所有开启 的全部 minor mode 的信息。（你如果发现已经设置过的 mode 没开，可能因为没有设置成 global 的）。

• major mode 里面还有一个重要的概念是 hook。一个 major mode（ /e.g.
Emac-lisp-mode/ ）相当于一个 list，就是一些它自带的 function。但这里还可以有一串
儿 minor mode 挂在上面。这个 major mode 开启默认所有 list 上的特性都会被自动加载。
如果我们需要的设置没有，需要手动添加，有可能是通过 hook，一般对于每个特定的 pack
如果使用 hook，GitHub 上有具体设置指南。例如 ~(add-hook 'emacs-lisp-mode-hook
'show-paren-mode)~ . [[./static/img/emacs 21 1-1.jpg]]
	
• Hook 就是一串特定的 functions: A hook is a Lisp variable which holds a list of functions, to be called on some well-defined occasion. 大部分 hook 都尽量是 normal 且一致的，方便全局调用，我们也会自己通过 add-hook 加 function 到 hook 上来满足特殊的需求。自行设计 hook list 要注意顺序问题，因为上文提到一串 function 是按顺序依次执行的，如果后面的会影响前面的，那么顺序自定义就很重要。相关阅读: [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Hooks.html][Hooks - GNU Emacs Manual - https://www.gnu.org/]]

• Emacs 操作系统很像一个大的状态机，储存着很多可修改的状态。Mode 调用和设置也是通过 function 修改 value 实现。Emacs 虽然因为没有变量空间而导致所有变量全局可见,但是因为 mode 的 default 设置，使得有些 value 只是 buffer local 的(aka mode 每个 buffer 都独立保留了一份 default 值)，如果需要在全局应用某些 mode，要注意上 hook 或者修改 global setting，注意查看每个安装文档的说明。

• 如上文所说，让 mode 生效有三种方式（1）临时调用 M-x company-mode，可以反复修改 value，但有可能只修改了临时 buffer local value（2）直接修改 mode.el 脚本；都不如这种好：(3) 写好 mode 设置放在 init.el 里面让它在 Emacs 开启时设置好。
【2-2'10】以 company-mode 为例讲解以上知识：mode 的种类（还有其他 state）开启还是关闭，本身是 value，每个 buffer 都有储存一份，所以 setq 只会修改本 buffer 的值，setq-default 才会修改全体 buffer 的值。只有当一个 value 生来就是全局变动的时候，setq 和 setq-default 才是一回事。set-key 也是类似，如下注意左右列的区别，尤其当想要的修改下次没生效，查看变量是否是 buffer local 很重要。例如以下区别：
| (company-mode t)        | (global-company-mode t)          |
| (setq cursor-type 'bar) | (setq-default  cursor-type 'bar) |
| (set-key ..)            | (global-set-key …)               |

*** 4. 在 init.el 中安装 packages
-----
	• 裸机 Emacs 系统除了部分内置的功能，什么 cutomerized 设置都没有，因此我们手动安装想要 packages。第一次安装是从 option-manage packages 用 GUI 安装，等同于调用 M-x package-list-packages，但安装不仅是加载，系统同时自动同时在 init.el 生成 M-x package-list-packages list，以便以后在任何电脑上都可以自动复现。所以我们可以从 init.el 从命令的角度看看这是如何实现的。
	
	• 以后我们也会通过在 init.el 里编写 packages list 来实现群体安装。
	
	• 默认 packages 都装在.emacs.d/elpa 目录下面，即所有有关这个 package 的文件都下载到一个文件夹下面，以供 emacs load【注意这个跟.emacs.d/lisp 文件不要混淆】。

**** 4.1 Auto-load 【2-15’00】
    • 装好后重新打开 Emacs，我们看到 init.el 文件第一行要求是
	~（package-initialize)~ 意思是自动去 elpa 目录里找安装好的 package，挨个扫描，找到 package-autoload.el 文件执行，预加载一些函数名进 workspace。为什么会有再初始时就有加载 autoload 这一过程呢？
	
	• 请思考如下问题。如果没有 autoload，你可以在 init.el 加载时就 load 各种各样的脚本，使得 emacs 在启动时就把整个使用过程中可能用到的函数一次性准备好。但这样真的好么？
	autoload 告诉 emacs 某个地方有一个定义好的函数，并且告诉 emacs，先别加载，只要记住在调用这个函数时去哪里寻找它的定义即可。这样做的一个好处是，避免在启动 emacs 时因为执行过多代码而效率低下，比如启动慢，卡系统等。想象一下，如果你安装了大量的有关 python 开发的插件，而某次打开 emacs 只是希望写点日记，你肯定不希望这些插件在启动时就被加载，让你白白等上几秒，也不希望这些插件在你做文本编辑时抢占系统资源（内存，CPU 时间等）。所以，一个合理的配置应该是，当你打开某个 python 脚本，或者手动进入 python 的编辑模式时，才加载那些插件.
	
	• autoload 定义的函数都可以直接调用，而不需要 require，like company-mode。所以 autoload 行为的意义用一个简单的概括是：“只注册函数名而不定义函数本身”。
	
它执行过程如下，以 company 为例。在这个 package 安装好后 ，我们可以在.emacs.d/elpa 下看
到 company 文件夹，包含了 company-xxxfunction.el 和一系列自解码.elc 二进制文件，这些
即是 company-mode 的全部执行细节。Emacs 会自动遍历 company-20160325 里面所有文件，提取所有注释里有魔法语句；；;autoload 的内容，并根据这个注释自动生成一个一个的魔法语句块，全部存在 company-autoload.elc 文件里。例如一下魔法语句块就是根据第一行从 company.el 自动生成的：



**** 4.2 Non-autoload []

** DONE Installing Source Code Pro in Ubuntu and MS Windows plateform 2019 【2019 版 Souce Code Pro 字体安装指南】 :@TECH:Ubuntu:
   CLOSED: [2019-09-03 Tue 21:53]
   :PROPERTIES:
   :EXPORT_FILE_NAME: source-code-pro-在-ubuntu-和-ms-windows 的安装
   :END:
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2019-09-03 Tue 21:53]
   :END:

#+begin_description 
Installing source code pro and trouble shooting.
#+end_description 

使用 Emacs 的时候，有时候会用到 Source Code Pro 字体，尤其是 Spacemacs 以它作为
默认字体。未安装会造成 Emacs 启动时出现报错。可以使用以下方式安
装 2019 年 2.03 版本字体。

*** MS Windows
以下网址给了详细的图片操作步骤：
[[https://simpletutorials.com/c/2759/How+to+install+the+default+Spacemacs+font+on+Windows][Simple Tutorials - htddtps://simpletutorials.com/]]

*** Ubuntu
Linux 下安装，由下载，解压，编译，粘贴，删除源文件等一系列操作组成，所以我附上 shell 脚
本一键操作。
脚本来自：[[https://www.rogerpence.com/posts/install-source-code-pro-font-on-ubuntu][rogerpence.com | Install Source Code Pro font on Ubuntu - https://www.rogerpence.com/]]

【注意】如果手动输入，或者代码报错，文件名称最好使用 =自动补全= 。

1. Home 目录下新建脚本
#+begin_src emacs-lisp
  touch ~/install-source-code-pro.sh
#+end_src
2. 把脚本模式改成可执行文件
#+begin_src elisp
  sudo chmod +x install-source-code-pro.sh
#+end_src
3. 填写脚本内容并保存
#+Begin_src sh
  #!/usr/bin/env bash
  cd Downloads

  wget https://github.com/adobe-fonts/source-code-pro/archive/2.030R-ro/1.050R-it.zip

  if [ ! -d "~/.fonts" ] ; then
  mkdir ~/.fonts
  fi

  unzip 1.050R-it.zip 

  cp source-code-pro-*-it/OTF/*.otf ~/.fonts/
  rm -rf source-code-pro* 
  rm 1.050R-it.zip 

  cd ~/

  fc-cache -f -v
#+end_src

4. 执行脚本
#+begin_src shell
  ./install-source-code-pro.sh
#+end_src

使用愉快:) 
** DONE Using aspell in windows 10 and Emacs 26 above 【拼写检查 Emacs26 使用更新版 aspell】 :@TECH:Emacs:Spacemacs:Windows10:
   CLOSED: [2019-09-13 Fri 01:34]
   :PROPERTIES:
   :EXPORT_FILE_NAME: using-aspell-in-windows-10-and-emacs-26-above
   :END:
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2019-09-13 Fri 01:34]
   :END:

 #+begin_description
Installing aspell for Emacs 26+ in windows system.
 #+end_description

I just realized that my ispell doesn't work after updating my Emacs to 27.0
version. I kept getting errors that:
 
 #+begin_src emacs-lisp
aspell release 0.60 or greater is required
 #+end_src

[[https://emacs.stackexchange.com/questions/41892/aspell-with-emacs-26-1-on-ms-windows/45752#45752][flyspell - aspell with emacs 26.1 on ms windows - Emacs Stack Exchange - https://emacs.stackexchange.com/]]

The above discussion shows that by the time being of emacs 26 released, there was no
binary aspell in windows OS, so the workaround was to use hunspell. Now the =final solution= has been provided by installing aspell with *Msys2*.

更新 Emacs 以后发现 aspell 不能用了，调用 ~ispell-minor-mode~ 时一直收到以上报错，查
看以上 stack exchange 的答案发现， 错误原因是 Emacs 26 以上的版本刚发布的时候 windows 还没有与
之匹配的 aspell 安装版本，所
以当时解决方式时暂时用 hunspell 代替。现在，匹配版 aspell 已经发布, 所以下文记录了： =用msys2安装aspell= 。

1. In MingW64 terminal search aspell:
 #+begin_src 
   pacman -Ss aspell
 #+end_src

2. Installing =aspell= and =dictionary you need= :
 #+begin_src
   pacman -S mingw64/mingw-w64-x86_64-aspell
   pacman -S mingw64/mingw-w64-x86_64-aspell-en
 #+end_src

3. Find aspell.exe location with ~which aspell~, e.g. ~C:\msys64\mingw64\bin~ 

4. Update in dotfile. Especially in Spacemacs:
 #+begin_src emacs-lisp
   (add-to-list 'exec-path "C:/msys64/mingw64/bin/")
   (setq ispell-program-name "aspell")
   (setq ispell-personal-dictionary "c:/msys64/mingw64/lib/aspell-0.60/en_GB")
 #+end_src
 
Done.
-----
More awesome (Chinese) articles of spell checking in Emacs, reading with google
translation if needed:

[[http://blog.lujun9972.win/blog/2018/06/03/emacs%E5%B8%AE%E4%BD%A0%E8%BF%9B%E8%A1%8C%E8%8B%B1%E6%96%87%E5%86%99%E4%BD%9C/][Emacs帮你进行英文写作 - 暗无天日 - http://blog.lujun9972.win/]]

[[https://www.hahack.com/tools/ispell-and-flyspell/][ispell与emacs的拼写检查 | HaHack - https://www.hahack.com/]]
** TODO Emacs line truncation in text editing mode
   :PROPERTIES:
   :EXPORT_FILE_NAME: emacs-line-truncation-in-text-editing-mode
   :END:
 
Emacs has dog. The quick brown fox jumps over the lazy dog. The quick brown fox jumps over
the lazy dog. The quick brown fox jumps over the lazy dog.The quick brown fox
jumps over the lazy dog.
